---
title: "Hour a Day: AI - Day 20 - Finally Refactoring"
date: 2025-04-15T18:43:02-04:00
categories:
  - "Hour a Day: AI"
tags:
  - ai
---

After a good night's rest I felt reinvigorated to figure this issue out!

## Time to Get this figured out!

> **Prompt:**
>
> How can I update all line endings on my file to be unix like via the command line
>

{{< details "**Response:** (click to expand)" >}}
> You can update all line endings in your files to Unix-style (LF) using the `git` command line. Here are a few approaches:
> 
> ### Option 1: Configure Git and re-checkout files
> 
> ```bash
> # Set Git to use LF line endings for all files
> git config core.autocrlf false
> git config core.eol lf
> 
> # Re-checkout all files to apply the new line ending settings
> git rm --cached -r .
> git reset --hard
> ```
> 
> ### Option 2: Use `dos2unix` utility
> 
> If you have the `dos2unix` utility installed:
> 
> ```bash
> # Convert all files in the repository
> find . -type f -not -path "*/\.git/*" -exec dos2unix {} \;
> ```
> 
> ### Option 3: Use `sed` command
> 
> ```bash
> # Replace CRLF with LF in all files
> find . -type f -not -path "*/\.git/*" -exec sed -i 's/\r$//' {} \;
> ```
> 
> ### Option 4: Configure Git attributes
> 
> Create or update a `.gitattributes` file in your repository root:
> 
> ```
> # Set default behavior to automatically normalize line endings
> * text=auto eol=lf
> 
> # Explicitly declare text files you want to always be normalized
> *.cs text eol=lf
> *.md text eol=lf
> *.json text eol=lf
> # Add other file extensions as needed
> ```
> 
> Then run:
> 
> ```bash
> # Apply the attributes
> git add --renormalize .
> git commit -m "Normalize all line endings to LF"
> ```
> 
> The first or fourth options are generally preferred for Git repositories as they ensure consistent line endings across all environments.
> 
> > Tokens: 8.2k sent, 361 received. Cost: $0.03 message, $0.03 session.
{{< /details >}}

**Verdict:** ✅ While I needed to figure out the issue, the tool did provide some decent options to fix it.

## Fix these tests!

> **Prompt:**
>
> Run the unit tests
>

{{< details "**Response:** (click to expand)" >}}
> To run the unit tests in your project, I'll need to suggest the appropriate command. Based on the file structure and test files I see, it appears you're using a .NET project with NUnit for testing.
> 
> ```bash
> dotnet test
> ```
> 
> This command will run all the unit tests in your project. If you want to run specific tests or get more detailed output, you could use additional parameters.
> 
> > Tokens: 11k sent, 83 received. Cost: $0.03 message, $0.03 session.  
> > dotnet test  
> > Run shell command? (Y)es/(N)o/(D)on't ask again [Yes]: y  
> > Running dotnet test  
> > Add command output to the chat? (Y)es/(N)o/(D)on't ask again [Yes]: y  
> > Added 6939 lines of output to the chat.
{{< /details >}}

**Verdict:** ❌ We'll see, but it mostly failed at this task

## Well, not really 

> **Prompt:**
>
> For the tests that failed above, they are flaky and sometimes pass and sometimes don't. Can you provide some ideas based on my test implementations on something that could be done to make them less flaky?
>

{{< details "**Response:** (click to expand)" >}}
> Based on the test failures you're seeing, I can suggest several approaches to make your tests less flaky. Let's analyze the failures and provide some solutions:
> 
> Analysis of Failures
> 
> The failures are occurring in the `ForecastMenuTests.cs` file, specifically in:
> 1. `ShouldDrawExitButton` - Expected coordinates don't match actual coordinates
> 2. `ShouldDrawRow` - Issues with row counts and position values
> 
> These types of UI-related test failures are common sources of flakiness because they often depend on:
> - Screen resolution
> - UI scaling
> - Timing issues
> - Rendering differences
> 
> Recommendations to Reduce Flakiness
> 
> 1. Use Relative Positioning Instead of Absolute
> 
> Instead of asserting exact pixel coordinates, consider testing relative positions or relationships:
> 
> ```csharp
> // Instead of:
> Assert.That(actualX, Is.EqualTo(expectedX));
> Assert.That(actualY, Is.EqualTo(expectedY));
> 
> // Consider:
> Assert.That(actualX, Is.InRange(expectedX - tolerance, expectedX + tolerance));
> Assert.That(actualY, Is.InRange(expectedY - tolerance, expectedY + tolerance));
> ```
> 
> 2. Add Tolerance to Position Assertions
> 
> For UI elements, add a reasonable tolerance to account for minor rendering differences:
> 
> ```csharp
> private const int PositionTolerance = 5; // or whatever makes sense for your UI
> 
> // Then in tests:
> Assert.That(actualPosition, Is.EqualTo(expectedPosition).Within(PositionTolerance));
> ```
> 
> 3. Mock UI Dependencies More Thoroughly
> 
> Ensure your test environment has consistent UI properties by mocking:
> - Screen dimensions
> - UI scaling factors
> - Font rendering
> 
> 4. Deterministic Test Setup
> 
> Make sure your test setup creates a completely deterministic environment:
> - Set fixed random seeds if randomness is involved
> - Initialize UI components with fixed dimensions
> - Reset any static state between tests
> 
> 5. Test Behavior Instead of Implementation Details
> 
> Instead of testing exact coordinates, test the behavior or relationships:
> 
> ```csharp
> // Instead of testing exact coordinates
> Assert.That(exitButton.X, Is.EqualTo(5439));
> 
> // Test that the button is in the right area of the screen
> Assert.That(exitButton.X, Is.GreaterThan(screenWidth * 0.8));
> Assert.That(exitButton.Y, Is.LessThan(screenHeight * 0.3));
> ```
> 
> 6. Parameterize Tests with Different Screen Sizes
> 
> If you're testing UI that should work across different screen sizes, parameterize your tests:
> 
> ```csharp
> [TestCase(1920, 1080)]
> [TestCase(1280, 720)]
> [TestCase(3840, 2160)]
> public void ShouldDrawExitButton(int screenWidth, int screenHeight)
> {
>     // Test with calculations based on screen dimensions rather than hard-coded values
>     var expectedX = screenWidth - 100; // Example calculation
>     var expectedY = screenHeight / 4;  // Example calculation
>     
>     // Then test with tolerance
>     Assert.That(actualX, Is.InRange(expectedX - 10, expectedX + 10));
> }
> ```
> 
> 7. Implement Test-Specific Rendering Logic
> 
> For UI components, consider adding test-specific rendering paths that are more deterministic:
> 
> ```csharp
> public Vector2 CalculateButtonPosition(int screenWidth, int screenHeight, bool isTestMode = false)
> {
>     if (isTestMode)
>     {
>         // Return deterministic position for testing
>         return new Vector2(screenWidth * 0.9f, screenHeight * 0.2f);
>     }
>     
>     // Normal calculation with potential variability
>     return CalculateActualButtonPosition();
> }
> ```
> 
> 8. Capture and Log Detailed State on Failure
> 
> Add detailed logging to capture the state when tests fail:
> 
> ```csharp
> try
> {
>     Assert.That(actualX, Is.EqualTo(expectedX));
>     Assert.That(actualY, Is.EqualTo(expectedY));
> }
> catch (AssertionException)
> {
>     Console.WriteLine($"Test failed with screen dimensions: {screenWidth}x{screenHeight}");
>     Console.WriteLine($"Expected position: ({expectedX}, {expectedY})");
>     Console.WriteLine($"Actual position: ({actualX}, {actualY})");
>     Console.WriteLine($"UI scale factor: {uiScale}");
>     // Log other relevant state
>     throw;
> }
> ```
> 
> 9. Use Setup/Teardown to Ensure Consistent State
> 
> Make sure your test environment is reset properly between tests:
> 
> ```csharp
> [SetUp]
> public void Setup()
> {
>     // Reset UI state, screen dimensions, etc.
>     ResetUIState();
>     SetFixedScreenDimensions(1920, 1080);
>     SetFixedUIScale(1.0f);
> }
> ```
> 
> 10. Consider Snapshot Testing
> 
> For complex UI, consider implementing snapshot testing where you compare the entire rendered output rather than individual coordinates.
> 
> By implementing these strategies, you should be able to significantly reduce the flakiness in your UI tests while still ensuring your UI components are working correctly.
> 
> > Tokens: 98k sent, 1.0k received. Cost: $0.31 message, $0.34 session.  
> > Tests/menu/ForecastMenuTests.cs  
> > Add file to the chat? (Y)es/(N)o/(D)on't ask again [Yes]: y  
> 
> Thank you for sharing the `ForecastMenuTests.cs` file. After reviewing it, I can provide more specific recommendations to address the flakiness in your tests.
> 
> Let's look at the failing tests in detail:
> 
> 1. `ShouldDrawExitButton` - The test is failing because the expected coordinates (5439, 2581) don't match the actual coordinates (6324, 2092).
> 
> 2. `ShouldDrawRow` - There are issues with the expected number of right arrow calls (expected 1, got 3) and the expected name location (expected 1003, got 1443).
> 
> Here are my specific recommendations:
> 
> 1. Add Tolerance to Position Assertions
> 
> For the `ShouldDrawExitButton` test, add tolerance to the position assertions:
> 
> ```csharp
> [TestCase(1080, 620, 944, 42)]
> [TestCase(10800, 6200, 5439, 2581)]
> public void ShouldDrawExitButton(int screenWidth, int screenHeight, int x, int y)
> {
>     Game1.uiViewport.Width = screenWidth;
>     Game1.uiViewport.Height = screenHeight;
> 
>     _menu.draw(_batch);
> 
>     var exitButton = HarmonyClickableTextureComponent.DrawCalls.ToArray()[4].Key;
>     
>     // Define a tolerance based on screen size
>     var xTolerance = screenWidth * 0.1; // 10% of screen width
>     var yTolerance = screenHeight * 0.1; // 10% of screen height
>     
>     Assert.Multiple(() =>
>     {
>         Assert.That(exitButton.bounds.X, Is.InRange(x - xTolerance, x + xTolerance), 
>             $"Exit button X position {exitButton.bounds.X} is not within range of {x} ± {xTolerance}");
>         Assert.That(exitButton.bounds.Y, Is.InRange(y - yTolerance, y + yTolerance),
>             $"Exit button Y position {exitButton.bounds.Y} is not within range of {y} ± {yTolerance}");
>     });
> }
> ```
> 
> 2. Make Assertions More Flexible for `ShouldDrawRow`
> 
> For the `ShouldDrawRow` test, make the assertions more flexible:
> 
> ```csharp
> // Instead of checking for exact counts:
> Assert.That(HarmonyClickableTextureComponent.DrawCalls[positiveDeltaArrows!], Is.EqualTo(expectedRightArrowCalls));
> 
> // Consider a range or a minimum:
> Assert.That(HarmonyClickableTextureComponent.DrawCalls[positiveDeltaArrows!], 
>     Is.GreaterThanOrEqualTo(expectedRightArrowCalls), 
>     $"Expected at least {expectedRightArrowCalls} right arrow calls");
> ```
> 
> For position checks:
> ```csharp
> // Define a position tolerance
> var positionTolerance = 500; // Adjust based on your UI scale
> 
> // For name location:
> Assert.That(expectedNameLocation, Is.InRange(expectedNameLocation - positionTolerance, expectedNameLocation + positionTolerance),
>     $"Name location {expectedNameLocation} is not within range");
> ```
> 
> 3. Ensure Deterministic Test Environment
> 
> Make sure your test environment is consistent:
> 
> ```csharp
> [SetUp]
> public override void Setup()
> {
>     base.Setup();
> 
>     // Set fixed random seed if randomness is involved
>     Random.InitState(42);
>     
>     // Clear any static state
>     HarmonyClickableTextureComponent.DrawCalls.Clear();
>     HarmonyIClickableMenu.DrawHoriztonalPartitionCalls.Clear();
>     HarmonySpriteBatch.DrawCalls.Clear();
>     
>     // Rest of your setup...
> }
> ```
> 
> 4. Test Relative Positions Instead of Absolute
> 
> For UI elements, test their relative positions:
> 
> ```csharp
> [TestCase(1080, 620)]
> [TestCase(10800, 6200)]
> public void ShouldDrawExitButtonInTopRight(int screenWidth, int screenHeight)
> {
>     Game1.uiViewport.Width = screenWidth;
>     Game1.uiViewport.Height = screenHeight;
> 
>     _menu.draw(_batch);
> 
>     var exitButton = HarmonyClickableTextureComponent.DrawCalls.ToArray()[4].Key;
>     
>     // Check that the button is in the top-right quadrant
>     Assert.Multiple(() =>
>     {
>         Assert.That(exitButton.bounds.X, Is.GreaterThan(screenWidth / 2), "Exit button should be in right half");
>         Assert.That(exitButton.bounds.Y, Is.LessThan(screenHeight / 2), "Exit button should be in top half");
>     });
> }
> ```
> 
> 5. Improve Test Isolation
> 
> Make sure each test is properly isolated:
> 
> ```csharp
> [TearDown]
> public void Teardown()
> {
>     _batch.Dispose();
>     
>     // Clear static state
>     HarmonyClickableTextureComponent.DrawCalls.Clear();
>     HarmonyIClickableMenu.DrawHoriztonalPartitionCalls.Clear();
>     HarmonySpriteBatch.DrawCalls.Clear();
>     HarmonyObject.DrawInMenuCalls.Clear();
> }
> ```
> 
> 6. Add Diagnostic Information
> 
> Add more diagnostic information to help debug failures:
> 
> ```csharp
> public void ShouldDrawExitButton(int screenWidth, int screenHeight, int x, int y)
> {
>     Game1.uiViewport.Width = screenWidth;
>     Game1.uiViewport.Height = screenHeight;
> 
>     _menu.draw(_batch);
> 
>     var exitButton = HarmonyClickableTextureComponent.DrawCalls.ToArray()[4].Key;
>     
>     // Log diagnostic information
>     Console.WriteLine($"Screen dimensions: {screenWidth}x{screenHeight}");
>     Console.WriteLine($"Expected exit button position: ({x}, {y})");
>     Console.WriteLine($"Actual exit button position: ({exitButton.bounds.X}, {exitButton.bounds.Y})");
>     
>     // Rest of the test...
> }
> ```
> 
> 7. Consider Refactoring the UI Code
> 
> If possible, refactor the UI code to make it more testable:
> 
> - Use relative positioning based on screen dimensions
> - Extract position calculation logic to make it more deterministic
> - Add test hooks that allow for more predictable behavior during tests
> 
> By implementing these changes, you should be able to make your tests more robust and less flaky. The key is to focus on testing the important aspects of your UI (like relative positioning and behavior) rather than exact pixel coordinates that might vary slightly between runs.
> 
> > Tokens: 103k sent, 1.3k received. Cost: $0.33 message, $0.67 session.
{{< /details >}}

**Verdict:** ❌ 5 was really only the option that was anywhere close to what was needed

## Trying again

> **Prompt:**
>
> Can you propose a few changes that would make my tests not be so flaky.
>

{{< details "**Response:** (click to expand)" >}}
> Reducing Test Flakiness in ForecastMenuTests
> 
> After reviewing your test code, I can see several areas where the tests might be flaky due to dependencies on exact pixel positions, hardcoded values, and complex test setups. Here are my recommendations:
> 
> 1. Use Relative Positioning Instead of Absolute Coordinates
> 
> Many of your tests are asserting exact pixel coordinates, which makes them brittle to UI changes:
> 
> ```csharp
> // Instead of this:
> Assert.That(upArrow.Key.bounds.X, Is.EqualTo(upArrowExpectedX), "Up Arrow X position does not match expectation");
> 
> // Consider something like this:
> Assert.That(upArrow.Key.bounds.X, Is.GreaterThan(menu.xPositionOnScreen), "Up Arrow X should be within menu bounds");
> Assert.That(upArrow.Key.bounds.X, Is.LessThan(menu.xPositionOnScreen + menu.width), "Up Arrow X should be within menu bounds");
> ```
> 
> 2. Create Helper Methods for Common Test Setup
> 
> Your tests have a lot of repeated setup code. Create helper methods to reduce duplication:
> 
> ```csharp
> private void SetupScreenSize(int width, int height)
> {
>     Game1.uiViewport.Width = width;
>     Game1.uiViewport.Height = height;
> }
> 
> private void SetupCategoryItems(int category, ItemModel[] items)
> {
>     _economyServiceMock.Setup(m => m.GetItemsForCategory(category)).Returns(items);
> }
> ```
> 
> 3. Reduce Dependency on Implementation Details
> 
> Instead of testing exact pixel positions, test the relationships between UI elements:
> 
> ```csharp
> // Test that elements are in the correct order
> Assert.That(upArrow.Key.bounds.Y, Is.LessThan(downArrow.Key.bounds.Y), "Up arrow should be above down arrow");
> 
> // Test that elements are properly aligned
> Assert.That(Math.Abs(upArrow.Key.bounds.X - downArrow.Key.bounds.X), Is.LessThanOrEqualTo(1), "Arrows should be vertically aligned");
> ```
> 
> 4. Use Tolerance for Numeric Comparisons
> 
> When comparing positions or sizes, use a tolerance to allow for minor variations:
> 
> ```csharp
> // Instead of exact equality
> Assert.That(runner.x, Is.EqualTo(runnerExpectedX), "Runner X position does not match expectation");
> 
> // Use a tolerance
> Assert.That(runner.x, Is.EqualTo(runnerExpectedX).Within(2), "Runner X position should be approximately correct");
> ```
> 
> 5. Separate Layout Tests from Functional Tests
> 
> Split your tests into two categories:
> - Layout tests that verify basic positioning relationships
> - Functional tests that verify behavior without depending on exact positions
> 
> ```csharp
> [Test]
> public void ShouldHaveCorrectLayoutStructure()
> {
>     // Test general layout relationships without exact pixels
> }
> 
> [Test]
> public void ShouldRespondCorrectlyToUserInteractions()
> {
>     // Test functionality without depending on exact positions
> }
> ```
> 
> 6. Create a Custom Assertion for UI Element Positioning
> 
> ```csharp
> private void AssertElementInBounds(Rectangle elementBounds, Rectangle containerBounds, string message)
> {
>     Assert.Multiple(() =>
>     {
>         Assert.That(elementBounds.Left, Is.GreaterThanOrEqualTo(containerBounds.Left), $"{message} - Left edge out of bounds");
>         Assert.That(elementBounds.Right, Is.LessThanOrEqualTo(containerBounds.Right), $"{message} - Right edge out of bounds");
>         Assert.That(elementBounds.Top, Is.GreaterThanOrEqualTo(containerBounds.Top), $"{message} - Top edge out of bounds");
>         Assert.That(elementBounds.Bottom, Is.LessThanOrEqualTo(containerBounds.Bottom), $"{message} - Bottom edge out of bounds");
>     });
> }
> ```
> 
> 7. Reduce the Number of Test Cases
> 
> Instead of testing many different screen sizes with exact pixel positions, test fewer representative cases with more flexible assertions:
> 
> ```csharp
> [TestCase(1080, 620, "small screen")]
> [TestCase(10800, 6200, "large screen")]
> public void ShouldDrawScrollBarElementsInCorrectRelativePositions(int screenWidth, int screenHeight, string description)
> {
>     // Test with more flexible assertions
> }
> ```
> 
> 8. Mock Time-Dependent Operations
> 
> If any animations or time-dependent operations are causing flakiness, mock them to ensure consistent behavior.
> 
> 9. Implement a More Robust Test for Draw Calls
> 
> Instead of counting exact draw calls, verify that essential elements are drawn at least once:
> 
> ```csharp
> Assert.That(HarmonyClickableTextureComponent.DrawCalls.Keys.Any(c => c.name == "up-arrow"), 
>     "Up arrow should be drawn");
> ```
> 
> 10. Create a Stable Test Environment
> 
> Ensure your test environment is stable by resetting all static state between tests:
> 
> ```csharp
> [TearDown]
> public void Teardown()
> {
>     _batch.Dispose();
>     HarmonyClickableTextureComponent.DrawCalls.Clear();
>     HarmonyIClickableMenu.DrawHoriztonalPartitionCalls.Clear();
>     HarmonySpriteBatch.DrawCalls.Clear();
>     // Reset other static state
> }
> ```
> 
> These changes should make your tests more resilient to UI changes and reduce flakiness while still verifying the important functionality of your ForecastMenu.
> 
> > Tokens: 13k sent, 1.0k received. Cost: $0.05 message, $0.05 session.
{{< /details >}}

**Verdict:** ❌ I tried again but resetting context. The results were not any better

## This is not simple

> **Prompt:**
>
> can you provide a plan for implementing option 10 across my testing code base. I'd like something common for all of my harmony mocks
>

{{< details "**Response:** (click to expand)" >}}
> Plan for Implementing a Stable Test Environment Across Harmony Mocks
> 
> Here's a comprehensive plan to implement a stable test environment for all your Harmony mocks, ensuring that static state is properly reset between tests:
> 
> 1. Create a Central Reset Mechanism
> 
> First, let's create a central mechanism to reset all Harmony mock state:
> 
> ```csharp
> // Create a new file: Tests/HarmonyMocks/HarmonyResetManager.cs
> namespace Tests.HarmonyMocks;
> 
> public static class HarmonyResetManager
> {
>     private static readonly List<Action> ResetActions = new();
> 
>     /// <summary>
>     /// Register a reset action that will be called when ResetAll is invoked
>     /// </summary>
>     public static void RegisterResetAction(Action resetAction)
>     {
>         ResetActions.Add(resetAction);
>     }
> 
>     /// <summary>
>     /// Reset all registered Harmony mock state
>     /// </summary>
>     public static void ResetAll()
>     {
>         foreach (var action in ResetActions)
>         {
>             action();
>         }
>     }
> }
> ```
> 
> 2. Modify Each Harmony Mock Class
> 
> Update each Harmony mock class to register its reset actions and provide a Reset method:
> 
> ```csharp
> // Example for HarmonyClickableTextureComponent.cs
> public class HarmonyClickableTextureComponent
> {
>     public static Dictionary<ClickableTextureComponent, int> DrawCalls;
>     
>     public static void Setup(Harmony harmony)
>     {
>         harmony.Patch(
>             AccessTools.Method(typeof(ClickableTextureComponent), nameof(ClickableTextureComponent.draw), new []{typeof(SpriteBatch)}),
>             prefix: new HarmonyMethod(typeof(HarmonyClickableTextureComponent), nameof(MockDraw))
>         );
> 
>         DrawCalls = new();
>         
>         // Register reset action
>         HarmonyResetManager.RegisterResetAction(Reset);
>     }
>     
>     // Add a Reset method to clear state
>     public static void Reset()
>     {
>         DrawCalls.Clear();
>     }
>     
>     static bool MockDraw(ClickableTextureComponent __instance)
>     {
>         DrawCalls.TryAdd(__instance, 0);
>         DrawCalls[__instance]++;
>         return false;
>     }
> }
> ```
> 
> 3. Update HarmonyTestBase
> 
> Modify your HarmonyTestBase class to call the reset manager in both Setup and TearDown:
> 
> ```csharp
> public class HarmonyTestBase
> {
>     [SetUp]
>     public virtual void Setup()
>     {
>         // Reset all Harmony mock state before setting up
>         HarmonyResetManager.ResetAll();
>         
>         var harmony = new Harmony("fse.tests");
> 
>         HarmonyFarmer.Setup(harmony);
>         HarmonyGame.Setup(harmony);
>         // ... other setup calls
>     }
>     
>     [TearDown]
>     public virtual void TearDown()
>     {
>         // Reset all Harmony mock state after each test
>         HarmonyResetManager.ResetAll();
>     }
> }
> ```
> 
> 4. Standardize State Management in All Harmony Mocks
> 
> For each Harmony mock class, follow this pattern:
> 
> 1. Make all state fields static and public
> 2. Initialize state in the Setup method
> 3. Add a Reset method that clears all state
> 4. Register the Reset method with HarmonyResetManager
> 
> Example template for each Harmony mock:
> 
> ```csharp
> public class HarmonyExampleMock
> {
>     // 1. Static state fields
>     public static Dictionary<ExampleType, int> CallCounts;
>     public static List<ExampleArguments> ReceivedArguments;
>     
>     public static void Setup(Harmony harmony)
>     {
>         // 2. Initialize state
>         CallCounts = new();
>         ReceivedArguments = new();
>         
>         // Patch methods
>         harmony.Patch(/* ... */);
>         
>         // 3. Register reset
>         HarmonyResetManager.RegisterResetAction(Reset);
>     }
>     
>     // 4. Reset method
>     public static void Reset()
>     {
>         CallCounts.Clear();
>         ReceivedArguments.Clear();
>     }
>     
>     // Mock methods...
> }
> ```
> 
> 5. Create a Checklist for All Harmony Mocks
> 
> Here's a checklist of all your Harmony mock classes that need to be updated:
> 
> - [ ] HarmonyClickableTextureComponent
> - [ ] HarmonyCollectionsPage
> - [ ] HarmonyExitPage
> - [ ] HarmonyFarm
> - [ ] HarmonyFarmer
> - [ ] HarmonyFarmerCollection
> - [ ] HarmonyFarmerTeam
> - [ ] HarmonyGame
> - [ ] HarmonyGameMenu
> - [ ] HarmonyGraphicsDeviceManager
> - [ ] HarmonyIClickableMenu
> - [ ] HarmonyItem
> - [ ] HarmonyLetterViewMenu
> - [ ] HarmonyLocalizedContentManager
> - [ ] HarmonyMapPage
> - [ ] HarmonyModMessageReceivedEventArgs
> - [ ] HarmonyObject
> - [ ] HarmonyOptions
> - [ ] HarmonyOptionsCheckbox
> - [ ] HarmonyOptionsDropDown
> - [ ] HarmonyOptionsTextEntry
> - [ ] HarmonySpriteBatch
> - [ ] HarmonySpriteFont
> - [ ] HarmonyTextBox
> - [ ] HarmonyTexture2D
> - [ ] HarmonyUtility
> 
> 6. Add Diagnostic Logging
> 
> To help identify which mocks might be causing issues, add diagnostic logging:
> 
> ```csharp
> public static class HarmonyResetManager
> {
>     // ... existing code
>     
>     public static void ResetAll()
>     {
>         foreach (var action in ResetActions)
>         {
>             try
>             {
>                 action();
>             }
>             catch (Exception ex)
>             {
>                 Console.WriteLine($"Error resetting Harmony mock: {ex.Message}");
>                 // You could also log which action failed if you store more info
>             }
>         }
>     }
> }
> ```
> 
> 7. Create a Test to Verify Reset Functionality
> 
> Add a test to verify that the reset functionality works correctly:
> 
> ```csharp
> [TestFixture]
> public class HarmonyResetTests : HarmonyTestBase
> {
>     [Test]
>     public void ShouldResetAllHarmonyMockState()
>     {
>         // Arrange - Create some state in various mocks
>         HarmonyClickableTextureComponent.DrawCalls[new ClickableTextureComponent()] = 5;
>         HarmonySpriteBatch.DrawCalls[new SpriteBatch(null)] = new List<DrawCall>();
>         
>         // Act - Reset all state
>         HarmonyResetManager.ResetAll();
>         
>         // Assert - Verify state is cleared
>         Assert.That(HarmonyClickableTextureComponent.DrawCalls, Is.Empty);
>         Assert.That(HarmonySpriteBatch.DrawCalls, Is.Empty);
>         // Add assertions for other mocks
>     }
> }
> ```
> 
> 8. Implementation Strategy
> 
> To implement this across your codebase:
> 
> 1. Create the HarmonyResetManager first
> 2. Update HarmonyTestBase to use it
> 3. Update a few key Harmony mocks that are causing the most flakiness
> 4. Run tests to verify improvement
> 5. Gradually update the remaining mocks
> 6. Add the verification test
> 
> This approach allows you to make incremental improvements while ensuring you don't break existing tests.
> 
> 9. Additional Considerations
> 
> - Consider adding a `RegisterStaticField<T>` method to HarmonyResetManager that can automatically reset collections
> - For complex objects that need special reset logic, you might need custom reset methods
> - If some tests require different initial states, consider adding a way to customize the reset behavior per test
> 
> By implementing this plan, you'll create a robust framework for managing Harmony mock state across your test suite, significantly reducing test flakiness caused by state leakage between tests.
> 
> > Tokens: 14k sent, 1.5k received. Cost: $0.06 message, $0.12 session.
{{< /details >}}

**Verdict:** ❌ This is way too complicated. This need to be a lot more simple

## Can't fix it

> **Prompt:**
>
> Modify that plan to embed the reset manager directly inside of harmony test base
>

{{< details "**Response:** (click to expand)" >}}
>  Revised Plan: Embedding Reset Manager in HarmonyTestBase
> 
> Here's a revised plan that embeds the reset manager functionality directly within the HarmonyTestBase class, creating a more centralized approach:
> 
> 1. Enhance HarmonyTestBase with Reset Management
> 
> ```csharp
> // Update Tests/HarmonyTestBase.cs
> using HarmonyLib;
> using Tests.HarmonyMocks;
> using System;
> using System.Collections.Generic;
> 
> namespace Tests;
> 
> public class HarmonyTestBase
> {
>     // List of reset actions to be called during setup and teardown
>     private static readonly List<Action> ResetActions = new();
>     
>     // Method to register reset actions
>     protected static void RegisterResetAction(Action resetAction)
>     {
>         ResetActions.Add(resetAction);
>     }
>     
>     // Method to reset all registered state
>     protected static void ResetAllMockState()
>     {
>         foreach (var action in ResetActions)
>         {
>             try
>             {
>                 action();
>             }
>             catch (Exception ex)
>             {
>                 Console.WriteLine($"Error resetting Harmony mock: {ex.Message}");
>             }
>         }
>     }
> 
>     [SetUp]
>     public virtual void Setup()
>     {
>         // Reset all mock state before setting up new tests
>         ResetAllMockState();
>         
>         var harmony = new Harmony("fse.tests");
> 
>         HarmonyFarmer.Setup(harmony);
>         HarmonyGame.Setup(harmony);
>         HarmonyFarmerCollection.Setup(harmony);
>         HarmonyFarmerTeam.Setup(harmony);
>         HarmonyFarm.Setup(harmony);
>         HarmonyObject.Setup(harmony);
>         HarmonyModMessageReceivedEventArgs.Setup(harmony);
>         HarmonySpriteFont.Setup(harmony);
>         HarmonyUtility.Setup(harmony);
>         HarmonySpriteBatch.Setup(harmony);
>         HarmonyGameMenu.Setup(harmony);
>         HarmonyOptions.Setup(harmony);
>         HarmonyTexture2D.Setup(harmony);
>         HarmonyIClickableMenu.Setup(harmony);
>         HarmonyMapPage.Setup(harmony);
>         HarmonyCollectionsPage.Setup(harmony);
>         HarmonyLetterViewMenu.Setup(harmony);
>         HarmonyOptionsDropDown.Setup(harmony);
>         HarmonyOptionsCheckbox.Setup(harmony);
>         HarmonyGraphicsDeviceManager.Setup(harmony);
>         HarmonyClickableTextureComponent.Setup(harmony);
>         HarmonyItem.Setup(harmony);
>         HarmonyLocalizedContentManager.Setup(harmony);
>         HarmonyOptionsTextEntry.Setup(harmony);
>         HarmonyTextBox.Setup(harmony);
>         HarmonyExitPage.Setup(harmony);
>     }
>     
>     [TearDown]
>     public virtual void TearDown()
>     {
>         // Reset all mock state after each test
>         ResetAllMockState();
>     }
> }
> ```
> 
> 2. Modify Each Harmony Mock Class
> 
> Update each Harmony mock class to register its reset action with the HarmonyTestBase:
> 
> ```csharp
> // Example for HarmonyClickableTextureComponent.cs
> public class HarmonyClickableTextureComponent
> {
>     public static Dictionary<ClickableTextureComponent, int> DrawCalls;
>     
>     public static void Setup(Harmony harmony)
>     {
>         harmony.Patch(
>             AccessTools.Method(typeof(ClickableTextureComponent), nameof(ClickableTextureComponent.draw), new []{typeof(SpriteBatch)}),
>             prefix: new HarmonyMethod(typeof(HarmonyClickableTextureComponent), nameof(MockDraw))
>         );
> 
>         // Initialize state
>         DrawCalls = new();
>         
>         // Register reset action with HarmonyTestBase
>         HarmonyTestBase.RegisterResetAction(Reset);
>     }
>     
>     // Add a Reset method to clear state
>     public static void Reset()
>     {
>         DrawCalls = new Dictionary<ClickableTextureComponent, int>();
>     }
>     
>     static bool MockDraw(ClickableTextureComponent __instance)
>     {
>         DrawCalls.TryAdd(__instance, 0);
>         DrawCalls[__instance]++;
>         return false;
>     }
> }
> ```
> 
> 3. Make RegisterResetAction Public
> 
> Since the Harmony mock classes need to access the RegisterResetAction method, we need to make it public:
> 
> ```csharp
> // In HarmonyTestBase.cs
> public static void RegisterResetAction(Action resetAction)
> {
>     ResetActions.Add(resetAction);
> }
> ```
> 
> 4. Standardize State Management in All Harmony Mocks
> 
> For each Harmony mock class, follow this pattern:
> 
> 1. Make all state fields static and public
> 2. Initialize state in the Setup method
> 3. Add a Reset method that clears all state
> 4. Register the Reset method with HarmonyTestBase.RegisterResetAction
> 
> Example template for each Harmony mock:
> 
> ```csharp
> public class HarmonyExampleMock
> {
>     // 1. Static state fields
>     public static Dictionary<ExampleType, int> CallCounts;
>     public static List<ExampleArguments> ReceivedArguments;
>     
>     public static void Setup(Harmony harmony)
>     {
>         // 2. Initialize state
>         CallCounts = new();
>         ReceivedArguments = new();
>         
>         // Patch methods
>         harmony.Patch(/* ... */);
>         
>         // 3. Register reset with HarmonyTestBase
>         HarmonyTestBase.RegisterResetAction(Reset);
>     }
>     
>     // 4. Reset method
>     public static void Reset()
>     {
>         CallCounts = new Dictionary<ExampleType, int>();
>         ReceivedArguments = new List<ExampleArguments>();
>     }
>     
>     // Mock methods...
> }
> ```
> 
> 5. Create a Checklist for All Harmony Mocks
> 
> Here's a checklist of all your Harmony mock classes that need to be updated:
> 
> - [ ] HarmonyClickableTextureComponent
> - [ ] HarmonyCollectionsPage
> - [ ] HarmonyExitPage
> - [ ] HarmonyFarm
> - [ ] HarmonyFarmer
> - [ ] HarmonyFarmerCollection
> - [ ] HarmonyFarmerTeam
> - [ ] HarmonyGame
> - [ ] HarmonyGameMenu
> - [ ] HarmonyGraphicsDeviceManager
> - [ ] HarmonyIClickableMenu
> - [ ] HarmonyItem
> - [ ] HarmonyLetterViewMenu
> - [ ] HarmonyLocalizedContentManager
> - [ ] HarmonyMapPage
> - [ ] HarmonyModMessageReceivedEventArgs
> - [ ] HarmonyObject
> - [ ] HarmonyOptions
> - [ ] HarmonyOptionsCheckbox
> - [ ] HarmonyOptionsDropDown
> - [ ] HarmonyOptionsTextEntry
> - [ ] HarmonySpriteBatch
> - [ ] HarmonySpriteFont
> - [ ] HarmonyTextBox
> - [ ] HarmonyTexture2D
> - [ ] HarmonyUtility
> 
> 6. Create a Test to Verify Reset Functionality
> 
> Add a test to verify that the reset functionality works correctly:
> 
> ```csharp
> [TestFixture]
> public class HarmonyResetTests : HarmonyTestBase
> {
>     [Test]
>     public void ShouldResetAllHarmonyMockState()
>     {
>         // Arrange - Create some state in various mocks
>         HarmonyClickableTextureComponent.DrawCalls[new ClickableTextureComponent()] = 5;
>         HarmonySpriteBatch.DrawCalls[new SpriteBatch(null)] = new List<DrawCall>();
>         
>         // Act - Reset all state
>         ResetAllMockState();
>         
>         // Assert - Verify state is cleared
>         Assert.That(HarmonyClickableTextureComponent.DrawCalls, Is.Empty);
>         Assert.That(HarmonySpriteBatch.DrawCalls, Is.Empty);
>         // Add assertions for other mocks
>     }
> }
> ```
> 
> 7. Implementation Strategy
> 
> To implement this across your codebase:
> 
> 1. Update HarmonyTestBase first with the reset management functionality
> 2. Update a few key Harmony mocks that are causing the most flakiness
> 3. Run tests to verify improvement
> 4. Gradually update the remaining mocks
> 5. Add the verification test
> 
> 8. Additional Considerations
> 
> - For complex objects that need special reset logic, you might need custom reset methods
> - Consider adding a helper method in HarmonyTestBase for common reset patterns:
> 
> ```csharp
> // In HarmonyTestBase.cs
> public static void RegisterDictionaryReset<TKey, TValue>(ref Dictionary<TKey, TValue> dictionary)
> {
>     RegisterResetAction(() => dictionary = new Dictionary<TKey, TValue>());
> }
> 
> public static void RegisterListReset<T>(ref List<T> list)
> {
>     RegisterResetAction(() => list = new List<T>());
> }
> ```
> 
> This approach centralizes the reset management within your existing HarmonyTestBase class, making it easier to maintain and ensuring that all tests properly clean up their state.
> 
> > Tokens: 16k sent, 1.7k received. Cost: $0.07 message, $0.19 session.  
> >  
> >  
> > ^C again to exit  
> >  
> >  
> > ^C KeyboardInterrupt
{{< /details >}}

**Verdict:** ❌ Trying to amend the plan had no effect. Let's start again fresh.

## New Prompt

> **Prompt:**
>
> make a plan to have `HarmonyTestBase` to have a teardown method that calls teardown on all of the harmony mocks as well as making plans to have each harmony mock to implement the necessary teardown to reset fields that were setup
>

{{< details "**Response:** (click to expand)" >}}
> Plan for Implementing Teardown in HarmonyTestBase
> 
> Here's a plan to implement a proper teardown mechanism for the HarmonyTestBase class and all Harmony mocks:
> 
> 1. First, add a TearDown method to HarmonyTestBase that will call teardown on all Harmony mocks
> 2. Create an interface or pattern for the Harmony mocks to implement teardown functionality
> 3. Modify each Harmony mock class to implement the teardown functionality
> 4. Ensure all static fields or state in the mocks are properly reset
> 
> Step 1: Add TearDown method to HarmonyTestBase
> 
> ```csharp
> [TearDown]
> public virtual void TearDown()
> {
>     HarmonyFarmer.TearDown();
>     HarmonyGame.TearDown();
>     HarmonyFarmerCollection.TearDown();
>     HarmonyFarmerTeam.TearDown();
>     HarmonyFarm.TearDown();
>     HarmonyObject.TearDown();
>     HarmonyModMessageReceivedEventArgs.TearDown();
>     HarmonySpriteFont.TearDown();
>     HarmonyUtility.TearDown();
>     HarmonySpriteBatch.TearDown();
>     HarmonyGameMenu.TearDown();
>     HarmonyOptions.TearDown();
>     HarmonyTexture2D.TearDown();
>     HarmonyIClickableMenu.TearDown();
>     HarmonyMapPage.TearDown();
>     HarmonyCollectionsPage.TearDown();
>     HarmonyLetterViewMenu.TearDown();
>     HarmonyOptionsDropDown.TearDown();
>     HarmonyOptionsCheckbox.TearDown();
>     HarmonyGraphicsDeviceManager.TearDown();
>     HarmonyClickableTextureComponent.TearDown();
>     HarmonyItem.TearDown();
>     HarmonyLocalizedContentManager.TearDown();
>     HarmonyOptionsTextEntry.TearDown();
>     HarmonyTextBox.TearDown();
>     HarmonyExitPage.TearDown();
> }
> ```
> 
> Step 2: Pattern for Harmony mocks
> 
> For each Harmony mock class, we need to:
> 
> 1. Add a static `TearDown()` method
> 2. Identify all static fields that need to be reset
> 3. Reset those fields to their default values in the TearDown method
> 
> Step 3: Example implementation for a Harmony mock class
> 
> For each mock class, the implementation would look something like:
> 
> ```csharp
> public class HarmonyFarmer
> {
>     // Static fields that need to be reset
>     private static bool _isMainPlayer = false;
>     private static long _uniqueMultiplayerId = 0;
>     // Other static fields...
> 
>     public static void Setup(Harmony harmony)
>     {
>         // Existing setup code...
>         _isMainPlayer = true; // Example of setting a field
>     }
> 
>     public static void TearDown()
>     {
>         // Reset all static fields to default values
>         _isMainPlayer = false;
>         _uniqueMultiplayerId = 0;
>         // Reset other fields...
>     }
>     
>     // Existing mock methods...
> }
> ```
> 
> Step 4: Implementation considerations
> 
> 1. For each mock class, identify all static fields that maintain state between tests
> 2. Ensure all fields are properly reset to avoid test contamination
> 3. For mocks that use Harmony patches, consider if the patches need to be unpatched (though this might not be necessary if the Harmony instance is created fresh for each test)
> 4. For complex mocks, consider adding a static constructor to initialize default values that can be referenced in TearDown
> 
> This approach will ensure that each test starts with a clean state, preventing test contamination and making tests more reliable and predictable.
> 
> > Tokens: 5.0k sent, 691 received. Cost: $0.03 message, $0.03 session.
{{< /details >}}

**Verdict:** ✅ This did a better job when the ask was constrained

## Add teardown

> **Prompt:**
>
> using the plan described above, implement step 1
>

{{< details "**Response:** (click to expand)" >}}
> I'll implement Step 1 of the plan by adding a TearDown method to the HarmonyTestBase class.
> 
> Tests/HarmonyTestBase.cs
> ```csharp
> <<<<<<< SEARCH
> ﻿using HarmonyLib;
> using Tests.HarmonyMocks;
> namespace Tests;
> 
> public class HarmonyTestBase
> {
> 	[SetUp]
> 	public virtual void Setup()
> 	{
> 		var harmony = new Harmony("fse.tests");
> 
> 		HarmonyFarmer.Setup(harmony);
> 		HarmonyGame.Setup(harmony);
> 		HarmonyFarmerCollection.Setup(harmony);
> 		HarmonyFarmerTeam.Setup(harmony);
> 		HarmonyFarm.Setup(harmony);
> 		HarmonyObject.Setup(harmony);
> 		HarmonyModMessageReceivedEventArgs.Setup(harmony);
> 		HarmonySpriteFont.Setup(harmony);
> 		HarmonyUtility.Setup(harmony);
> 		HarmonySpriteBatch.Setup(harmony);
> 		HarmonyGameMenu.Setup(harmony);
> 		HarmonyOptions.Setup(harmony);
> 		HarmonyTexture2D.Setup(harmony);
> 		HarmonyIClickableMenu.Setup(harmony);
> 		HarmonyMapPage.Setup(harmony);
> 		HarmonyCollectionsPage.Setup(harmony);
> 		HarmonyLetterViewMenu.Setup(harmony);
> 		HarmonyOptionsDropDown.Setup(harmony);
> 		HarmonyOptionsCheckbox.Setup(harmony);
> 		HarmonyGraphicsDeviceManager.Setup(harmony);
> 		HarmonyClickableTextureComponent.Setup(harmony);
> 		HarmonyItem.Setup(harmony);
> 		HarmonyLocalizedContentManager.Setup(harmony);
> 		HarmonyOptionsTextEntry.Setup(harmony);
> 		HarmonyTextBox.Setup(harmony);
> 		HarmonyExitPage.Setup(harmony);
> 	}
> }
> =======
> ﻿using HarmonyLib;
> using Tests.HarmonyMocks;
> namespace Tests;
> 
> public class HarmonyTestBase
> {
> 	[SetUp]
> 	public virtual void Setup()
> 	{
> 		var harmony = new Harmony("fse.tests");
> 
> 		HarmonyFarmer.Setup(harmony);
> 		HarmonyGame.Setup(harmony);
> 		HarmonyFarmerCollection.Setup(harmony);
> 		HarmonyFarmerTeam.Setup(harmony);
> 		HarmonyFarm.Setup(harmony);
> 		HarmonyObject.Setup(harmony);
> 		HarmonyModMessageReceivedEventArgs.Setup(harmony);
> 		HarmonySpriteFont.Setup(harmony);
> 		HarmonyUtility.Setup(harmony);
> 		HarmonySpriteBatch.Setup(harmony);
> 		HarmonyGameMenu.Setup(harmony);
> 		HarmonyOptions.Setup(harmony);
> 		HarmonyTexture2D.Setup(harmony);
> 		HarmonyIClickableMenu.Setup(harmony);
> 		HarmonyMapPage.Setup(harmony);
> 		HarmonyCollectionsPage.Setup(harmony);
> 		HarmonyLetterViewMenu.Setup(harmony);
> 		HarmonyOptionsDropDown.Setup(harmony);
> 		HarmonyOptionsCheckbox.Setup(harmony);
> 		HarmonyGraphicsDeviceManager.Setup(harmony);
> 		HarmonyClickableTextureComponent.Setup(harmony);
> 		HarmonyItem.Setup(harmony);
> 		HarmonyLocalizedContentManager.Setup(harmony);
> 		HarmonyOptionsTextEntry.Setup(harmony);
> 		HarmonyTextBox.Setup(harmony);
> 		HarmonyExitPage.Setup(harmony);
> 	}
> 	
> 	[TearDown]
> 	public virtual void TearDown()
> 	{
> 		HarmonyFarmer.TearDown();
> 		HarmonyGame.TearDown();
> 		HarmonyFarmerCollection.TearDown();
> 		HarmonyFarmerTeam.TearDown();
> 		HarmonyFarm.TearDown();
> 		HarmonyObject.TearDown();
> 		HarmonyModMessageReceivedEventArgs.TearDown();
> 		HarmonySpriteFont.TearDown();
> 		HarmonyUtility.TearDown();
> 		HarmonySpriteBatch.TearDown();
> 		HarmonyGameMenu.TearDown();
> 		HarmonyOptions.TearDown();
> 		HarmonyTexture2D.TearDown();
> 		HarmonyIClickableMenu.TearDown();
> 		HarmonyMapPage.TearDown();
> 		HarmonyCollectionsPage.TearDown();
> 		HarmonyLetterViewMenu.TearDown();
> 		HarmonyOptionsDropDown.TearDown();
> 		HarmonyOptionsCheckbox.TearDown();
> 		HarmonyGraphicsDeviceManager.TearDown();
> 		HarmonyClickableTextureComponent.TearDown();
> 		HarmonyItem.TearDown();
> 		HarmonyLocalizedContentManager.TearDown();
> 		HarmonyOptionsTextEntry.TearDown();
> 		HarmonyTextBox.TearDown();
> 		HarmonyExitPage.TearDown();
> 	}
> }
> >>>>>>> REPLACE
> ```
> 
> This implements Step 1 of our plan by adding a TearDown method to the HarmonyTestBase class that calls TearDown on all the Harmony mock classes. The next step would be to implement the TearDown methods in each of the mock classes.
> 
> > Tokens: 8.0k sent, 1.0k received. Cost: $0.04 message, $0.06 session.  
> > Applied edit to Tests/HarmonyTestBase.cs  
> > Commit 72bea9a refactor: add TearDown method to HarmonyTestBase to reset Harmony mocks  
> > You can use /undo to undo and discard each aider commit.
> I'll implement TearDown methods for all the Harmony mocks referenced in the HarmonyTestBase class. Since I need to create these methods in multiple files, I'll need you to add each file to the chat as we go.
> 
> Let's start with a few examples of how these TearDown methods should be implemented. For each Harmony mock class, I'll need to:
> 
> 1. Add a static TearDown method
> 2. Reset any static fields that might be set during Setup or during test execution
> 
> Could you please add the following files to the chat so I can implement the TearDown methods:
> 
> 1. Tests/HarmonyMocks/HarmonyFarmer.cs
> 2. Tests/HarmonyMocks/HarmonyGame.cs
> 3. Tests/HarmonyMocks/HarmonyFarmerCollection.cs
> 
> Once I have these files, I can show you the implementation pattern and then we can proceed with the rest of the files.
> 
> > Tokens: 9.3k sent, 185 received. Cost: $0.03 message, $0.10 session.  
> > Tests/HarmonyMocks/HarmonyFarmer.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> > Tests/HarmonyMocks/HarmonyFarmerCollection.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> > Tests/HarmonyMocks/HarmonyGame.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> 
> I'll implement the TearDown methods for the three Harmony mock files you've added to the chat. Let's start with those:
> 
> Tests/HarmonyMocks/HarmonyFarmer.cs
> ```csharp
> <<<<<<< SEARCH
> using HarmonyLib;
> using StardewValley;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyFarmer
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(Farmer)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmer), nameof(MockConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Farmer), nameof(Farmer.UniqueMultiplayerID)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmer), nameof(MockUniqueMultiplayerID))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Farmer), nameof(Farmer.IsMainPlayer)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmer), nameof(MockIsMainPlayer))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Farmer), nameof(Farmer.team)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmer), nameof(MockGetTeam))
> 		);
> 
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Farmer), nameof(Farmer.Gender)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmer), nameof(MockGetGender))
> 
> 		);
> 		
> 		UniqueMultiplayerIdDictionary.Clear();
> 	}
> 
> 	static bool MockConstructor() => false;
> 
> 	public static Dictionary<Farmer, long> UniqueMultiplayerIdDictionary = new();
> 	public static Dictionary<Farmer, bool> IsMainPlayerDictionary = new();
> 	public static Dictionary<Farmer, FarmerTeam> FarmerTeamDictionary = new();
> 
> 	static bool MockUniqueMultiplayerID(
> 		Farmer __instance,
> 		ref long __result
> 	)
> 	{
> 		__result = UniqueMultiplayerIdDictionary[__instance];
> 		return false;
> 	}
> 	
> 	static bool MockIsMainPlayer(
> 		Farmer __instance,
> 		ref bool __result
> 	)
> 	{
> 		__result = IsMainPlayerDictionary[__instance];
> 		
> 		return false;
> 	}
> 	
> 	static bool MockGetTeam(
> 		Farmer __instance,
> 		ref FarmerTeam __result
> 	)
> 	{
> 		__result = FarmerTeamDictionary[__instance];
> 		
> 		return false;
> 	}
> 	
> 	static bool MockGetGender(
> 		Farmer __instance,
> 		ref Gender __result
> 	)
> 	{
> 		__result = Gender.Undefined;
> 		
> 		return false;
> 	}
> }
> =======
> ﻿using HarmonyLib;
> using StardewValley;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyFarmer
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(Farmer)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmer), nameof(MockConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Farmer), nameof(Farmer.UniqueMultiplayerID)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmer), nameof(MockUniqueMultiplayerID))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Farmer), nameof(Farmer.IsMainPlayer)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmer), nameof(MockIsMainPlayer))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Farmer), nameof(Farmer.team)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmer), nameof(MockGetTeam))
> 		);
> 
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Farmer), nameof(Farmer.Gender)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmer), nameof(MockGetGender))
> 
> 		);
> 		
> 		UniqueMultiplayerIdDictionary.Clear();
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		UniqueMultiplayerIdDictionary.Clear();
> 		IsMainPlayerDictionary.Clear();
> 		FarmerTeamDictionary.Clear();
> 	}
> 
> 	static bool MockConstructor() => false;
> 
> 	public static Dictionary<Farmer, long> UniqueMultiplayerIdDictionary = new();
> 	public static Dictionary<Farmer, bool> IsMainPlayerDictionary = new();
> 	public static Dictionary<Farmer, FarmerTeam> FarmerTeamDictionary = new();
> 
> 	static bool MockUniqueMultiplayerID(
> 		Farmer __instance,
> 		ref long __result
> 	)
> 	{
> 		__result = UniqueMultiplayerIdDictionary[__instance];
> 		return false;
> 	}
> 	
> 	static bool MockIsMainPlayer(
> 		Farmer __instance,
> 		ref bool __result
> 	)
> 	{
> 		__result = IsMainPlayerDictionary[__instance];
> 		
> 		return false;
> 	}
> 	
> 	static bool MockGetTeam(
> 		Farmer __instance,
> 		ref FarmerTeam __result
> 	)
> 	{
> 		__result = FarmerTeamDictionary[__instance];
> 		
> 		return false;
> 	}
> 	
> 	static bool MockGetGender(
> 		Farmer __instance,
> 		ref Gender __result
> 	)
> 	{
> 		__result = Gender.Undefined;
> 		
> 		return false;
> 	}
> }
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyFarmerCollection.cs
> ```csharp
> <<<<<<< SEARCH
> ﻿using System.Collections;
> using HarmonyLib;
> using StardewValley;
> using StardewValley.Network;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyFarmerCollection
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Method(typeof(FarmerCollection), nameof(FarmerCollection.GetEnumerator)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmerCollection), nameof(MockGetEnumerator))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(FarmerCollection.Enumerator), [typeof(GameLocation)]),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmerCollection), nameof(MockEnumeratorConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(FarmerCollection.Enumerator), nameof(FarmerCollection.Enumerator.Current)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmerCollection), nameof(MockEnumeratorCurrent))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(FarmerCollection.Enumerator), nameof(FarmerCollection.Enumerator.MoveNext)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmerCollection), nameof(MockEnumeratorMoveNext))
> 		);
> 	}
> 
> 	public static IEnumerator CollectionEnumerator;
> 
> 	static bool MockGetEnumerator() => false;
> 	static bool MockEnumeratorConstructor() => false;
> 	
> 	static bool MockEnumeratorCurrent(ref Farmer __result)
> 	{
> 		__result = CollectionEnumerator.Current as Farmer;
> 		return false;
> 	}
> 	
> 	static bool MockEnumeratorMoveNext(ref bool __result)
> 	{
> 		__result = CollectionEnumerator.MoveNext();
> 		return false;
> 	}
> }
> =======
> ﻿using System.Collections;
> using HarmonyLib;
> using StardewValley;
> using StardewValley.Network;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyFarmerCollection
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Method(typeof(FarmerCollection), nameof(FarmerCollection.GetEnumerator)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmerCollection), nameof(MockGetEnumerator))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(FarmerCollection.Enumerator), [typeof(GameLocation)]),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmerCollection), nameof(MockEnumeratorConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(FarmerCollection.Enumerator), nameof(FarmerCollection.Enumerator.Current)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmerCollection), nameof(MockEnumeratorCurrent))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(FarmerCollection.Enumerator), nameof(FarmerCollection.Enumerator.MoveNext)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmerCollection), nameof(MockEnumeratorMoveNext))
> 		);
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		CollectionEnumerator = null;
> 	}
> 
> 	public static IEnumerator CollectionEnumerator;
> 
> 	static bool MockGetEnumerator() => false;
> 	static bool MockEnumeratorConstructor() => false;
> 	
> 	static bool MockEnumeratorCurrent(ref Farmer __result)
> 	{
> 		__result = CollectionEnumerator.Current as Farmer;
> 		return false;
> 	}
> 	
> 	static bool MockEnumeratorMoveNext(ref bool __result)
> 	{
> 		__result = CollectionEnumerator.MoveNext();
> 		return false;
> 	}
> }
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyGame.cs
> ```csharp
> <<<<<<< SEARCH
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley;
> using StardewValley.Menus;
> using StardewValley.Network;
> 
> namespace Tests.HarmonyMocks;
> 
> public static class HarmonyGame
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Game1), nameof(Game1.player)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetPlayer))
> 		);
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Game1), nameof(Game1.activeClickableMenu)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetActiveClickableMenu))
> 		);
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Game1), nameof(Game1.options)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetOptions))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Game1), nameof(Game1.getOnlineFarmers)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetOnlineFarmers))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Game1), nameof(Game1.getAllFarmers)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetAllFarmers))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Game1), nameof(Game1.getFarm)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetFarm))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Game1), nameof(Game1.getSourceRectForStandardTileSheet)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetSourceRectForStandardTileSheet))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Game1), nameof(Game1.playSound), new []{typeof(string), typeof(int?)}),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockPlaySound))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(
> 				typeof(Game1), 
> 				nameof(Game1.drawDialogueBox), 
> 				new []
> 				{
> 					typeof(int),
> 					typeof(int),
> 					typeof(int),
> 					typeof(int),
> 					typeof(bool),
> 					typeof(bool),
> 					typeof(string),
> 					typeof(bool),
> 					typeof(bool),
> 					typeof(int),
> 					typeof(int),
> 					typeof(int)
> 				}
> 			),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockDrawDialogueBox))
> 		);
> 		DrawDialogueBoxCalls.Clear();
> 	}
> 
> 	public static Farmer GetPlayerResult { get; set; }
> 	static bool MockGetPlayer(ref Farmer __result)
> 	{
> 		__result = GetPlayerResult;
> 		return false;
> 	}
> 	
> 	public static FarmerCollection GetOnlineFarmersResults { get; set; }
> 	static bool MockGetOnlineFarmers(ref FarmerCollection __result)
> 	{
> 		__result = GetOnlineFarmersResults;
> 		return false;
> 	}
> 	
> 	public static IEnumerable<Farmer> GetAllFarmersResults { get; set; }
> 	static bool MockGetAllFarmers(ref IEnumerable<Farmer> __result)
> 	{
> 		__result = GetAllFarmersResults;
> 		return false;
> 	}
> 	
> 	public static Farm GetFarmResult { get; set; }
> 	static bool MockGetFarm(ref Farm __result)
> 	{
> 		__result = GetFarmResult;
> 		return false;
> 	}
> 	
> 	public static IClickableMenu GetActiveClickableMenuResult { get; set; }
> 	static bool MockGetActiveClickableMenu(ref IClickableMenu __result)
> 	{
> 		__result = GetActiveClickableMenuResult;
> 		return false;
> 	}
> 	public static Options GetOptionsResult { get; set; }
> 	static bool MockGetOptions(ref Options __result)
> 	{
> 		__result = GetOptionsResult;
> 		return false;
> 	}
> 
> 	public static List<(int x, int y, int width, int height, bool speaker, bool drawOnlyBox)>
> 		DrawDialogueBoxCalls { get; } = [];
> 
> 	static bool MockDrawDialogueBox
> 	(
> 		int x,
> 		int y,
> 		int width,
> 		int height,
> 		bool speaker,
> 		bool drawOnlyBox
> 	)
> 	{
> 		DrawDialogueBoxCalls.Add(new (x, y, width, height, speaker, drawOnlyBox));
> 		return false;
> 	}
> 	
> 	static bool MockGetSourceRectForStandardTileSheet(ref Rectangle __result)
> 	{
> 		__result = new Rectangle();
> 		return false;
> 	}
> 	
> 	static bool MockPlaySound(string cueName)
> 	{
> 		return false;
> 	}
> }
> =======
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley;
> using StardewValley.Menus;
> using StardewValley.Network;
> 
> namespace Tests.HarmonyMocks;
> 
> public static class HarmonyGame
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Game1), nameof(Game1.player)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetPlayer))
> 		);
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Game1), nameof(Game1.activeClickableMenu)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetActiveClickableMenu))
> 		);
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Game1), nameof(Game1.options)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetOptions))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Game1), nameof(Game1.getOnlineFarmers)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetOnlineFarmers))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Game1), nameof(Game1.getAllFarmers)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetAllFarmers))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Game1), nameof(Game1.getFarm)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetFarm))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Game1), nameof(Game1.getSourceRectForStandardTileSheet)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetSourceRectForStandardTileSheet))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Game1), nameof(Game1.playSound), new []{typeof(string), typeof(int?)}),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockPlaySound))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(
> 				typeof(Game1), 
> 				nameof(Game1.drawDialogueBox), 
> 				new []
> 				{
> 					typeof(int),
> 					typeof(int),
> 					typeof(int),
> 					typeof(int),
> 					typeof(bool),
> 					typeof(bool),
> 					typeof(string),
> 					typeof(bool),
> 					typeof(bool),
> 					typeof(int),
> 					typeof(int),
> 					typeof(int)
> 				}
> 			),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockDrawDialogueBox))
> 		);
> 		DrawDialogueBoxCalls.Clear();
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		GetPlayerResult = null;
> 		GetOnlineFarmersResults = null;
> 		GetAllFarmersResults = null;
> 		GetFarmResult = null;
> 		GetActiveClickableMenuResult = null;
> 		GetOptionsResult = null;
> 		DrawDialogueBoxCalls.Clear();
> 	}
> 
> 	public static Farmer GetPlayerResult { get; set; }
> 	static bool MockGetPlayer(ref Farmer __result)
> 	{
> 		__result = GetPlayerResult;
> 		return false;
> 	}
> 	
> 	public static FarmerCollection GetOnlineFarmersResults { get; set; }
> 	static bool MockGetOnlineFarmers(ref FarmerCollection __result)
> 	{
> 		__result = GetOnlineFarmersResults;
> 		return false;
> 	}
> 	
> 	public static IEnumerable<Farmer> GetAllFarmersResults { get; set; }
> 	static bool MockGetAllFarmers(ref IEnumerable<Farmer> __result)
> 	{
> 		__result = GetAllFarmersResults;
> 		return false;
> 	}
> 	
> 	public static Farm GetFarmResult { get; set; }
> 	static bool MockGetFarm(ref Farm __result)
> 	{
> 		__result = GetFarmResult;
> 		return false;
> 	}
> 	
> 	public static IClickableMenu GetActiveClickableMenuResult { get; set; }
> 	static bool MockGetActiveClickableMenu(ref IClickableMenu __result)
> 	{
> 		__result = GetActiveClickableMenuResult;
> 		return false;
> 	}
> 	public static Options GetOptionsResult { get; set; }
> 	static bool MockGetOptions(ref Options __result)
> 	{
> 		__result = GetOptionsResult;
> 		return false;
> 	}
> 
> 	public static List<(int x, int y, int width, int height, bool speaker, bool drawOnlyBox)>
> 		DrawDialogueBoxCalls { get; } = [];
> 
> 	static bool MockDrawDialogueBox
> 	(
> 		int x,
> 		int y,
> 		int width,
> 		int height,
> 		bool speaker,
> 		bool drawOnlyBox
> 	)
> 	{
> 		DrawDialogueBoxCalls.Add(new (x, y, width, height, speaker, drawOnlyBox));
> 		return false;
> 	}
> 	
> 	static bool MockGetSourceRectForStandardTileSheet(ref Rectangle __result)
> 	{
> 		__result = new Rectangle();
> 		return false;
> 	}
> 	
> 	static bool MockPlaySound(string cueName)
> 	{
> 		return false;
> 	}
> }
> >>>>>>> REPLACE
> ```
> 
> Now I need to implement TearDown methods for the remaining Harmony mock classes. Could you please add the following files to the chat:
> 
> 1. Tests/HarmonyMocks/HarmonyFarmerTeam.cs
> 2. Tests/HarmonyMocks/HarmonyFarm.cs
> 3. Tests/HarmonyMocks/HarmonyObject.cs
> 4. Tests/HarmonyMocks/HarmonyModMessageReceivedEventArgs.cs
> 5. Tests/HarmonyMocks/HarmonySpriteFont.cs
> 6. Tests/HarmonyMocks/HarmonyUtility.cs
> 7. Tests/HarmonyMocks/HarmonySpriteBatch.cs
> 
> > Tokens: 12k sent, 4.0k received. Cost: $0.10 message, $0.19 session.  
> > Tests/HarmonyMocks/HarmonyFarm.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> > Tests/HarmonyMocks/HarmonyFarmerTeam.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> > Tests/HarmonyMocks/HarmonyModMessageReceivedEventArgs.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> > Tests/HarmonyMocks/HarmonyObject.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> > Tests/HarmonyMocks/HarmonySpriteBatch.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> > Tests/HarmonyMocks/HarmonySpriteFont.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> > Tests/HarmonyMocks/HarmonyUtility.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> 
> I'll implement TearDown methods for the remaining Harmony mock classes. Here are the changes:
> 
> Tests/HarmonyMocks/HarmonyFarm.cs
> ```csharp
> <<<<<<< SEARCH
> using HarmonyLib;
> using StardewValley;
> using StardewValley.Inventories;
> 
> namespace Tests.HarmonyMocks;
> 
> public static class HarmonyFarm
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(Farm)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarm), nameof(MockConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Farm), nameof(Farm.getShippingBin)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarm), nameof(MockGetShippingBin))
> 		);
> 	}
> 
> 	static bool MockConstructor() => false;
> 	
> 	public static Dictionary<Farmer, IInventory> GetShippingBinDictionary = new();
> 	
> 	static bool MockGetShippingBin(
> 		Farmer who,
> 		ref IInventory __result
> 	)
> 	{
> 		__result = GetShippingBinDictionary[who];
> 		return false;
> 	}
> }
> =======
> ﻿using HarmonyLib;
> using StardewValley;
> using StardewValley.Inventories;
> 
> namespace Tests.HarmonyMocks;
> 
> public static class HarmonyFarm
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(Farm)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarm), nameof(MockConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Farm), nameof(Farm.getShippingBin)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarm), nameof(MockGetShippingBin))
> 		);
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		GetShippingBinDictionary.Clear();
> 	}
> 
> 	static bool MockConstructor() => false;
> 	
> 	public static Dictionary<Farmer, IInventory> GetShippingBinDictionary = new();
> 	
> 	static bool MockGetShippingBin(
> 		Farmer who,
> 		ref IInventory __result
> 	)
> 	{
> 		__result = GetShippingBinDictionary[who];
> 		return false;
> 	}
> }
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyFarmerTeam.cs
> ```csharp
> <<<<<<< SEARCH
> ﻿using System.Reflection;
> using HarmonyLib;
> using Netcode;
> using StardewModdingAPI;
> using StardewValley;
> 
> namespace Tests.HarmonyMocks;
> 
> public static class HarmonyFarmerTeam
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(FarmerTeam)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmerTeam), nameof(MockConstructor))
> 		);
> 	}
> 
> 	static bool MockConstructor() => false;
> 
> 	public static void SetUseSeparateWalletsResult(this FarmerTeam farmerTeam, bool value)
> 	{
> 		var field = AccessTools.Field(typeof(FarmerTeam), nameof(farmerTeam.useSeparateWallets));
> 
> 		field.SetValue(farmerTeam, new NetBool(value), BindingFlags.Public, null, null);
> 	}
> }
> =======
> ﻿using System.Reflection;
> using HarmonyLib;
> using Netcode;
> using StardewModdingAPI;
> using StardewValley;
> 
> namespace Tests.HarmonyMocks;
> 
> public static class HarmonyFarmerTeam
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(FarmerTeam)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmerTeam), nameof(MockConstructor))
> 		);
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		// No static fields to reset
> 	}
> 
> 	static bool MockConstructor() => false;
> 
> 	public static void SetUseSeparateWalletsResult(this FarmerTeam farmerTeam, bool value)
> 	{
> 		var field = AccessTools.Field(typeof(FarmerTeam), nameof(farmerTeam.useSeparateWallets));
> 
> 		field.SetValue(farmerTeam, new NetBool(value), BindingFlags.Public, null, null);
> 	}
> }
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyModMessageReceivedEventArgs.cs
> ```csharp
> <<<<<<< SEARCH
> using fse.core.multiplayer;
> using HarmonyLib;
> using StardewModdingAPI.Events;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyModMessageReceivedEventArgs
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(ModMessageReceivedEventArgs)),
> 			prefix: new HarmonyMethod(typeof(HarmonyModMessageReceivedEventArgs), nameof(MockConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			typeof(ModMessageReceivedEventArgs)
> 				.GetMethod(nameof(ModMessageReceivedEventArgs.ReadAs))!
> 				.MakeGenericMethod(typeof(IMessage)),
> 			prefix: new HarmonyMethod(typeof(HarmonyModMessageReceivedEventArgs), nameof(MockReadAs))
> 		);
> 	}
> 	
> 	static bool MockConstructor() => false;
> 	
> 	public static IMessage ReadAsMessage { get; set; }
> 	static bool MockReadAs(
> 		ref object __result
> 	)
> 	{
> 		__result = ReadAsMessage;
> 		return false;
> 	}
> }
> =======
> using fse.core.multiplayer;
> using HarmonyLib;
> using StardewModdingAPI.Events;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyModMessageReceivedEventArgs
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(ModMessageReceivedEventArgs)),
> 			prefix: new HarmonyMethod(typeof(HarmonyModMessageReceivedEventArgs), nameof(MockConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			typeof(ModMessageReceivedEventArgs)
> 				.GetMethod(nameof(ModMessageReceivedEventArgs.ReadAs))!
> 				.MakeGenericMethod(typeof(IMessage)),
> 			prefix: new HarmonyMethod(typeof(HarmonyModMessageReceivedEventArgs), nameof(MockReadAs))
> 		);
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		ReadAsMessage = null;
> 	}
> 	
> 	static bool MockConstructor() => false;
> 	
> 	public static IMessage ReadAsMessage { get; set; }
> 	static bool MockReadAs(
> 		ref object __result
> 	)
> 	{
> 		__result = ReadAsMessage;
> 		return false;
> 	}
> }
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyObject.cs
> ```csharp
> <<<<<<< SEARCH
> ﻿using System.Globalization;
> using HarmonyLib;
> using Microsoft.Xna.Framework;
> using Microsoft.Xna.Framework.Graphics;
> using Netcode;
> using StardewValley;
> using Object = StardewValley.Object;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyObject
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(Object), new []{typeof(string), typeof(int), typeof(bool), typeof(int), typeof(int)}),
> 			prefix: new HarmonyMethod(typeof(HarmonyObject), nameof(MockConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Item), nameof(Object.drawInMenu), new []
> 			{
> 				typeof(SpriteBatch),
> 				typeof(Vector2),
> 				typeof(float),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonyObject), nameof(MockDrawInMenu))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Object), nameof(Object.DisplayName)),
> 			prefix: new HarmonyMethod(typeof(HarmonyObject), nameof(MockGetDisplayName))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Object), nameof(Object.sellToStorePrice)),
> 			prefix: new HarmonyMethod(typeof(HarmonyObject), nameof(MockSellToStorePrice))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Object), nameof(Object.getCategoryName)),
> 			prefix: new HarmonyMethod(typeof(HarmonyObject), nameof(MockGetCategoryName))
> 		);
> 
> 		DrawInMenuCalls = new();
> 		ObjectIdCategoryMapping = new();
> 		CategoryIdToNameMapping = new();
> 		ObjectIdToPriceMapping = new();
> 		SellToStorePriceMapping = new();
> 	}
> 
> 	public static Dictionary<Object, List<Vector2>> DrawInMenuCalls;
> 	public static Dictionary<string, int> ObjectIdCategoryMapping;
> 	public static Dictionary<int, string> CategoryIdToNameMapping;
> 	public static Dictionary<string, int> ObjectIdToPriceMapping;
> 	public static Dictionary<Object, int> SellToStorePriceMapping;
> 
> 	static bool MockConstructor(
> 		ref Object __instance,
> 		string itemId,
> 		int initialStack
> 		)
> 	{
> 		__instance.itemId = new NetString();
> 		__instance.ItemId = itemId;
> 		if (ObjectIdCategoryMapping.TryGetValue(itemId, out var category))
> 		{
> 			__instance.Category = category;
> 		}
> 		
> 		#pragma warning disable AvoidNetField
> 		var stackField = AccessTools.Field(typeof(Object), nameof(Object.stack));
> 		#pragma warning restore AvoidNetField
> 		stackField.SetValue(__instance, new NetInt(initialStack));
> 
> 		if (ObjectIdToPriceMapping.TryGetValue(itemId, out var price))
> 		{
> 			#pragma warning disable AvoidNetField
> 			var priceField = AccessTools.Field(typeof(Object), nameof(Object.price));
> 			#pragma warning restore AvoidNetField
> 			priceField.SetValue(__instance, new NetInt(price));
> 		}
> 
> 		var parentField = AccessTools.Field(typeof(Object), nameof(Object.preservedParentSheetIndex));
> 		parentField.SetValue(__instance, new NetString());
> 		
> 		return false;
> 	}
> 	
> 	static bool MockDrawInMenu(
> 		ref Object __instance,
> 		Vector2 location
> 		)
> 	{
> 
> 		if (!DrawInMenuCalls.ContainsKey(__instance))
> 		{
> 			DrawInMenuCalls.Add(__instance, []);
> 		}
> 		
> 		DrawInMenuCalls[__instance].Add(location);
> 		
> 		return false;
> 	}
> 	static bool MockGetDisplayName(
> 		ref Object __instance,
> 		ref string __result
> 		)
> 	{
> 		__result = $"display-{__instance.ItemId}";
> 		return false;
> 	}
> 	
> 	static bool MockGetCategoryName(
> 		ref Object __instance,
> 		ref string __result
> 		)
> 	{
> 		if (CategoryIdToNameMapping.TryGetValue(__instance.Category, out var name))
> 		{
> 			__result = name;
> 		}
> 		return false;
> 	}
> 	
> 	static bool MockSellToStorePrice(
> 		ref Object __instance,
> 		ref int __result
> 		)
> 	{
> 		if (int.TryParse(__instance.ItemId, out var res))
> 		{
> 			__result = res;
> 		}
> 		else
> 		{
> 			__result = -1;
> 		}
> 		
> 		return false;
> 	}
> }
> =======
> ﻿using System.Globalization;
> using HarmonyLib;
> using Microsoft.Xna.Framework;
> using Microsoft.Xna.Framework.Graphics;
> using Netcode;
> using StardewValley;
> using Object = StardewValley.Object;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyObject
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(Object), new []{typeof(string), typeof(int), typeof(bool), typeof(int), typeof(int)}),
> 			prefix: new HarmonyMethod(typeof(HarmonyObject), nameof(MockConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Item), nameof(Object.drawInMenu), new []
> 			{
> 				typeof(SpriteBatch),
> 				typeof(Vector2),
> 				typeof(float),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonyObject), nameof(MockDrawInMenu))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Object), nameof(Object.DisplayName)),
> 			prefix: new HarmonyMethod(typeof(HarmonyObject), nameof(MockGetDisplayName))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Object), nameof(Object.sellToStorePrice)),
> 			prefix: new HarmonyMethod(typeof(HarmonyObject), nameof(MockSellToStorePrice))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Object), nameof(Object.getCategoryName)),
> 			prefix: new HarmonyMethod(typeof(HarmonyObject), nameof(MockGetCategoryName))
> 		);
> 
> 		DrawInMenuCalls = new();
> 		ObjectIdCategoryMapping = new();
> 		CategoryIdToNameMapping = new();
> 		ObjectIdToPriceMapping = new();
> 		SellToStorePriceMapping = new();
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		DrawInMenuCalls.Clear();
> 		ObjectIdCategoryMapping.Clear();
> 		CategoryIdToNameMapping.Clear();
> 		ObjectIdToPriceMapping.Clear();
> 		SellToStorePriceMapping.Clear();
> 	}
> 
> 	public static Dictionary<Object, List<Vector2>> DrawInMenuCalls;
> 	public static Dictionary<string, int> ObjectIdCategoryMapping;
> 	public static Dictionary<int, string> CategoryIdToNameMapping;
> 	public static Dictionary<string, int> ObjectIdToPriceMapping;
> 	public static Dictionary<Object, int> SellToStorePriceMapping;
> 
> 	static bool MockConstructor(
> 		ref Object __instance,
> 		string itemId,
> 		int initialStack
> 		)
> 	{
> 		__instance.itemId = new NetString();
> 		__instance.ItemId = itemId;
> 		if (ObjectIdCategoryMapping.TryGetValue(itemId, out var category))
> 		{
> 			__instance.Category = category;
> 		}
> 		
> 		#pragma warning disable AvoidNetField
> 		var stackField = AccessTools.Field(typeof(Object), nameof(Object.stack));
> 		#pragma warning restore AvoidNetField
> 		stackField.SetValue(__instance, new NetInt(initialStack));
> 
> 		if (ObjectIdToPriceMapping.TryGetValue(itemId, out var price))
> 		{
> 			#pragma warning disable AvoidNetField
> 			var priceField = AccessTools.Field(typeof(Object), nameof(Object.price));
> 			#pragma warning restore AvoidNetField
> 			priceField.SetValue(__instance, new NetInt(price));
> 		}
> 
> 		var parentField = AccessTools.Field(typeof(Object), nameof(Object.preservedParentSheetIndex));
> 		parentField.SetValue(__instance, new NetString());
> 		
> 		return false;
> 	}
> 	
> 	static bool MockDrawInMenu(
> 		ref Object __instance,
> 		Vector2 location
> 		)
> 	{
> 
> 		if (!DrawInMenuCalls.ContainsKey(__instance))
> 		{
> 			DrawInMenuCalls.Add(__instance, []);
> 		}
> 		
> 		DrawInMenuCalls[__instance].Add(location);
> 		
> 		return false;
> 	}
> 	static bool MockGetDisplayName(
> 		ref Object __instance,
> 		ref string __result
> 		)
> 	{
> 		__result = $"display-{__instance.ItemId}";
> 		return false;
> 	}
> 	
> 	static bool MockGetCategoryName(
> 		ref Object __instance,
> 		ref string __result
> 		)
> 	{
> 		if (CategoryIdToNameMapping.TryGetValue(__instance.Category, out var name))
> 		{
> 			__result = name;
> 		}
> 		return false;
> 	}
> 	
> 	static bool MockSellToStorePrice(
> 		ref Object __instance,
> 		ref int __result
> 		)
> 	{
> 		if (int.TryParse(__instance.ItemId, out var res))
> 		{
> 			__result = res;
> 		}
> 		else
> 		{
> 			__result = -1;
> 		}
> 		
> 		return false;
> 	}
> }
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonySpriteBatch.cs
> ```csharp
> <<<<<<< SEARCH
> using HarmonyLib;
> using Microsoft.Xna.Framework;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonySpriteBatch
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(SpriteBatch), new []{typeof(GraphicsDevice), typeof(int)}),
> 			prefix: new HarmonyMethod(typeof(HarmonySpriteBatch), nameof(MockConstructor))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(SpriteBatch), nameof(SpriteBatch.Draw),new []
> 			{
> 				typeof(Texture2D),
> 				typeof(Vector2),
> 				typeof(Rectangle),
> 				typeof(Color),
> 				typeof(float),
> 				typeof(Vector2),
> 				typeof(float),
> 				typeof(SpriteEffects),
> 				typeof(float)
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonySpriteBatch), nameof(MockDraw))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(SpriteBatch), nameof(SpriteBatch.Draw),new []
> 			{
> 				typeof(Texture2D),
> 				typeof(Rectangle),
> 				typeof(Color),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonySpriteBatch), nameof(MockDrawTiny))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(SpriteBatch), nameof(SpriteBatch.Draw),new []
> 			{
> 				typeof(Texture2D),
> 				typeof(Rectangle),
> 				typeof(Rectangle),
> 				typeof(Color),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonySpriteBatch), nameof(MockDrawSmall))
> 		);
> 
> 		DrawCalls = new();
> 	}
> 	
> 	static bool MockConstructor() => false;
> 
> 	public static Dictionary<SpriteBatch,
> 		List<(
> 		Texture2D texture,
> 		Vector2 position,
> 		Rectangle? destinationRectangle,
> 		Rectangle? sourceRectangle,
> 		Color color,
> 		float rotation,
> 		Vector2 origin,
> 		float scale,
> 		SpriteEffects effects,
> 		float layerDepth
> 		)>> DrawCalls;
> 
> 	static bool MockDraw(
> 		SpriteBatch __instance,
> 		Texture2D texture,
> 		Vector2 position,
> 		Rectangle? sourceRectangle,
> 		Color color,
> 		float rotation,
> 		Vector2 origin,
> 		float scale,
> 		SpriteEffects effects,
> 		float layerDepth
> 	)
> 	{
> 		if (!DrawCalls.ContainsKey(__instance))
> 		{
> 			DrawCalls.Add(__instance, []);
> 		}
> 		
> 		DrawCalls[__instance].Add((texture, position, null, sourceRectangle, color, rotation, origin, scale, effects, layerDepth));
> 		
> 		return false;
> 	}
> 	
> 	static bool MockDrawSmall(
> 		SpriteBatch __instance,
> 		Texture2D texture,
> 		Rectangle destinationRectangle,
> 		Rectangle? sourceRectangle,
> 		Color color
> 	)
> 	{
> 		if (!DrawCalls.ContainsKey(__instance))
> 		{
> 			DrawCalls.Add(__instance, []);
> 		}
> 		
> 		DrawCalls[__instance].Add((texture, Vector2.Zero, destinationRectangle, sourceRectangle, color, -1, Vector2.Zero, -1, SpriteEffects.None, -1));
> 		
> 		return false;
> 	}
> 	
> 	static bool MockDrawTiny(
> 		SpriteBatch __instance,
> 		Texture2D texture,
> 		Rectangle destinationRectangle,
> 		Color color
> 	)
> 	{
> 		if (!DrawCalls.ContainsKey(__instance))
> 		{
> 			DrawCalls.Add(__instance, []);
> 		}
> 		
> 		DrawCalls[__instance].Add((texture, Vector2.Zero, destinationRectangle, null, color, -1, Vector2.Zero, -1, SpriteEffects.None, -1));
> 		
> 		return false;
> 	}
> }
> =======
> using HarmonyLib;
> using Microsoft.Xna.Framework;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonySpriteBatch
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(SpriteBatch), new []{typeof(GraphicsDevice), typeof(int)}),
> 			prefix: new HarmonyMethod(typeof(HarmonySpriteBatch), nameof(MockConstructor))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(SpriteBatch), nameof(SpriteBatch.Draw),new []
> 			{
> 				typeof(Texture2D),
> 				typeof(Vector2),
> 				typeof(Rectangle),
> 				typeof(Color),
> 				typeof(float),
> 				typeof(Vector2),
> 				typeof(float),
> 				typeof(SpriteEffects),
> 				typeof(float)
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonySpriteBatch), nameof(MockDraw))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(SpriteBatch), nameof(SpriteBatch.Draw),new []
> 			{
> 				typeof(Texture2D),
> 				typeof(Rectangle),
> 				typeof(Color),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonySpriteBatch), nameof(MockDrawTiny))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(SpriteBatch), nameof(SpriteBatch.Draw),new []
> 			{
> 				typeof(Texture2D),
> 				typeof(Rectangle),
> 				typeof(Rectangle),
> 				typeof(Color),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonySpriteBatch), nameof(MockDrawSmall))
> 		);
> 
> 		DrawCalls = new();
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		DrawCalls.Clear();
> 	}
> 	
> 	static bool MockConstructor() => false;
> 
> 	public static Dictionary<SpriteBatch,
> 		List<(
> 		Texture2D texture,
> 		Vector2 position,
> 		Rectangle? destinationRectangle,
> 		Rectangle? sourceRectangle,
> 		Color color,
> 		float rotation,
> 		Vector2 origin,
> 		float scale,
> 		SpriteEffects effects,
> 		float layerDepth
> 		)>> DrawCalls;
> 
> 	static bool MockDraw(
> 		SpriteBatch __instance,
> 		Texture2D texture,
> 		Vector2 position,
> 		Rectangle? sourceRectangle,
> 		Color color,
> 		float rotation,
> 		Vector2 origin,
> 		float scale,
> 		SpriteEffects effects,
> 		float layerDepth
> 	)
> 	{
> 		if (!DrawCalls.ContainsKey(__instance))
> 		{
> 			DrawCalls.Add(__instance, []);
> 		}
> 		
> 		DrawCalls[__instance].Add((texture, position, null, sourceRectangle, color, rotation, origin, scale, effects, layerDepth));
> 		
> 		return false;
> 	}
> 	
> 	static bool MockDrawSmall(
> 		SpriteBatch __instance,
> 		Texture2D texture,
> 		Rectangle destinationRectangle,
> 		Rectangle? sourceRectangle,
> 		Color color
> 	)
> 	{
> 		if (!DrawCalls.ContainsKey(__instance))
> 		{
> 			DrawCalls.Add(__instance, []);
> 		}
> 		
> 		DrawCalls[__instance].Add((texture, Vector2.Zero, destinationRectangle, sourceRectangle, color, -1, Vector2.Zero, -1, SpriteEffects.None, -1));
> 		
> 		return false;
> 	}
> 	
> 	static bool MockDrawTiny(
> 		SpriteBatch __instance,
> 		Texture2D texture,
> 		Rectangle destinationRectangle,
> 		Color color
> 	)
> 	{
> 		if (!DrawCalls.ContainsKey(__instance))
> 		{
> 			DrawCalls.Add(__instance, []);
> 		}
> 		
> 		DrawCalls[__instance].Add((texture, Vector2.Zero, destinationRectangle, null, color, -1, Vector2.Zero, -1, SpriteEffects.None, -1));
> 		
> 		return false;
> 	}
> }
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonySpriteFont.cs
> ```csharp
> <<<<<<< SEARCH
> using HarmonyLib;
> using Microsoft.Xna.Framework;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonySpriteFont
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(
> 				typeof(SpriteFont),
> 				new []
> 				{
> 					typeof(Texture2D),
> 					typeof(List<Rectangle>),
> 					typeof(List<Rectangle>),
> 					typeof(List<char>),
> 					typeof(int),
> 					typeof(float),
> 					typeof(List<Vector3>),
> 					typeof(char?)
> 				}
> 			),
> 			prefix: new HarmonyMethod(typeof(HarmonySpriteFont), nameof(MockConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.Method(typeof(SpriteFont), nameof(SpriteFont.MeasureString), new []{typeof(string)}),
> 			prefix: new HarmonyMethod(typeof(HarmonySpriteFont), nameof(MockMeasureString))
> 		);
> 	}
> 	
> 	static bool MockConstructor() => false;
> 	
> 	public static Vector2 MeasureStringResult { get; set; }
> 	static bool MockMeasureString(ref Vector2 __result)
> 	{
> 		__result = MeasureStringResult;
> 		return false;
> 	}
> }
> =======
> using HarmonyLib;
> using Microsoft.Xna.Framework;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonySpriteFont
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(
> 				typeof(SpriteFont),
> 				new []
> 				{
> 					typeof(Texture2D),
> 					typeof(List<Rectangle>),
> 					typeof(List<Rectangle>),
> 					typeof(List<char>),
> 					typeof(int),
> 					typeof(float),
> 					typeof(List<Vector3>),
> 					typeof(char?)
> 				}
> 			),
> 			prefix: new HarmonyMethod(typeof(HarmonySpriteFont), nameof(MockConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.Method(typeof(SpriteFont), nameof(SpriteFont.MeasureString), new []{typeof(string)}),
> 			prefix: new HarmonyMethod(typeof(HarmonySpriteFont), nameof(MockMeasureString))
> 		);
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		MeasureStringResult = default;
> 	}
> 	
> 	static bool MockConstructor() => false;
> 	
> 	public static Vector2 MeasureStringResult { get; set; }
> 	static bool MockMeasureString(ref Vector2 __result)
> 	{
> 		__result = MeasureStringResult;
> 		return false;
> 	}
> }
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyUtility.cs
> ```csharp
> <<<<<<< SEARCH
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley;
> using StardewValley.Network;
> 
> namespace Tests.HarmonyMocks;
> 
> public static class HarmonyUtility
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Method(
> 				typeof(Utility), 
> 				nameof(Utility.drawTextWithShadow),
> 				new []
> 				{
> 					typeof(SpriteBatch),
> 					typeof(string),
> 					typeof(SpriteFont),
> 					typeof(Vector2),
> 					typeof(Color),
> 					typeof(float),
> 					typeof(float),
> 					typeof(int),
> 					typeof(int),
> 					typeof(float),
> 					typeof(int)
> 				}
> 			),
> 			prefix: new HarmonyMethod(typeof(HarmonyUtility), nameof(MockDrawTextWithShadow))
> 		);
> 		DrawTextWithShadowCalls.Clear();
> 	}
> 
> 	public static List<(SpriteBatch b, string text, SpriteFont font, Vector2 position, Color color)>
> 		DrawTextWithShadowCalls { get; } = [];
> 
> 	static bool MockDrawTextWithShadow
> 	(
> 		SpriteBatch b,
> 		string text,
> 		SpriteFont font,
> 		Vector2 position,
> 		Color color
> 	)
> 	{
> 		DrawTextWithShadowCalls.Add((b, text, font, position, color));
> 		return false;
> 	}
> }
> =======
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley;
> using StardewValley.Network;
> 
> namespace Tests.HarmonyMocks;
> 
> public static class HarmonyUtility
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Method(
> 				typeof(Utility), 
> 				nameof(Utility.drawTextWithShadow),
> 				new []
> 				{
> 					typeof(SpriteBatch),
> 					typeof(string),
> 					typeof(SpriteFont),
> 					typeof(Vector2),
> 					typeof(Color),
> 					typeof(float),
> 					typeof(float),
> 					typeof(int),
> 					typeof(int),
> 					typeof(float),
> 					typeof(int)
> 				}
> 			),
> 			prefix: new HarmonyMethod(typeof(HarmonyUtility), nameof(MockDrawTextWithShadow))
> 		);
> 		DrawTextWithShadowCalls.Clear();
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		DrawTextWithShadowCalls.Clear();
> 	}
> 
> 	public static List<(SpriteBatch b, string text, SpriteFont font, Vector2 position, Color color)>
> 		DrawTextWithShadowCalls { get; } = [];
> 
> 	static bool MockDrawTextWithShadow
> 	(
> 		SpriteBatch b,
> 		string text,
> 		SpriteFont font,
> 		Vector2 position,
> 		Color color
> 	)
> 	{
> 		DrawTextWithShadowCalls.Add((b, text, font, position, color));
> 		return false;
> 	}
> }
> >>>>>>> REPLACE
> ```
> 
> Now I need to implement TearDown methods for the remaining Harmony mock classes. Could you please add the following files to the chat:
> 
> 1. Tests/HarmonyMocks/HarmonyGameMenu.cs
> 2. Tests/HarmonyMocks/HarmonyOptions.cs
> 3. Tests/HarmonyMocks/HarmonyTexture2D.cs
> 4. Tests/HarmonyMocks/HarmonyIClickableMenu.cs
> 5. Tests/HarmonyMocks/HarmonyMapPage.cs
> 6. Tests/HarmonyMocks/HarmonyCollectionsPage.cs
> 7. Tests/HarmonyMocks/HarmonyLetterViewMenu.cs
> 8. Tests/HarmonyMocks/HarmonyOptionsDropDown.cs
> 9. Tests/HarmonyMocks/HarmonyOptionsCheckbox.cs
> 10. Tests/HarmonyMocks/HarmonyGraphicsDeviceManager.cs
> 11. Tests/HarmonyMocks/HarmonyClickableTextureComponent.cs
> 12. Tests/HarmonyMocks/HarmonyItem.cs
> 13. Tests/HarmonyMocks/HarmonyLocalizedContentManager.cs
> 14. Tests/HarmonyMocks/HarmonyOptionsTextEntry.cs
> 15. Tests/HarmonyMocks/HarmonyTextBox.cs
> 16. Tests/HarmonyMocks/HarmonyExitPage.cs
> 
> > Tokens: 19k sent, 6.2k received. Cost: $0.15 message, $0.34 session.  
> > Tests/HarmonyMocks/HarmonyClickableTextureComponent.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> > Tests/HarmonyMocks/HarmonyCollectionsPage.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> > Tests/HarmonyMocks/HarmonyExitPage.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> > Tests/HarmonyMocks/HarmonyGameMenu.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> > Tests/HarmonyMocks/HarmonyGraphicsDeviceManager.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> > Tests/HarmonyMocks/HarmonyIClickableMenu.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> > Tests/HarmonyMocks/HarmonyItem.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> > Tests/HarmonyMocks/HarmonyLetterViewMenu.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> > Tests/HarmonyMocks/HarmonyLocalizedContentManager.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> > Tests/HarmonyMocks/HarmonyMapPage.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> > Tests/HarmonyMocks/HarmonyOptions.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> > Tests/HarmonyMocks/HarmonyOptionsCheckbox.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> > Tests/HarmonyMocks/HarmonyOptionsDropDown.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> > Tests/HarmonyMocks/HarmonyOptionsTextEntry.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> > Tests/HarmonyMocks/HarmonyTextBox.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> > Tests/HarmonyMocks/HarmonyTexture2D.cs  
> > Add file to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> 
> I'll implement TearDown methods for all the remaining Harmony mock classes. Here are the changes:
> 
> Tests/HarmonyMocks/HarmonyClickableTextureComponent.cs
> ```csharp
> <<<<<<< SEARCH
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley.Menus;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyClickableTextureComponent
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch
> 			(
> 				AccessTools.Method(typeof(ClickableTextureComponent), nameof(ClickableTextureComponent.draw), new []{typeof(SpriteBatch)}),
> 				prefix: new HarmonyMethod(typeof(HarmonyClickableTextureComponent), nameof(MockDraw))
> 			);
> 
> 		DrawCalls = new();
> 	}
> 
> 	public static Dictionary<ClickableTextureComponent, int> DrawCalls;
> 	
> 	static bool MockDraw(ClickableTextureComponent __instance)
> 	{
> 		DrawCalls.TryAdd(__instance, 0);
> 		DrawCalls[__instance]++;
> 		return false;
> 	}
> }
> =======
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley.Menus;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyClickableTextureComponent
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch
> 			(
> 				AccessTools.Method(typeof(ClickableTextureComponent), nameof(ClickableTextureComponent.draw), new []{typeof(SpriteBatch)}),
> 				prefix: new HarmonyMethod(typeof(HarmonyClickableTextureComponent), nameof(MockDraw))
> 			);
> 
> 		DrawCalls = new();
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		DrawCalls.Clear();
> 	}
> 
> 	public static Dictionary<ClickableTextureComponent, int> DrawCalls;
> 	
> 	static bool MockDraw(ClickableTextureComponent __instance)
> 	{
> 		DrawCalls.TryAdd(__instance, 0);
> 		DrawCalls[__instance]++;
> 		return false;
> 	}
> }
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyCollectionsPage.cs
> ```csharp
> <<<<<<< SEARCH
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley.Menus;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyCollectionsPage
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(CollectionsPage), [typeof(int), typeof(int), typeof(int), typeof(int)]),
> 			prefix: new HarmonyMethod(typeof(HarmonyCollectionsPage), nameof(MockConstructor))
> 		);
> 	}
> 
> 	static bool MockConstructor() => false;
> }
> =======
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley.Menus;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyCollectionsPage
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(CollectionsPage), [typeof(int), typeof(int), typeof(int), typeof(int)]),
> 			prefix: new HarmonyMethod(typeof(HarmonyCollectionsPage), nameof(MockConstructor))
> 		);
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		// No static fields to reset
> 	}
> 
> 	static bool MockConstructor() => false;
> }
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyExitPage.cs
> ```csharp
> <<<<<<< SEARCH
> ﻿using HarmonyLib;
> using StardewValley.Menus;
> 
> namespace Tests.HarmonyMocks;
> public class HarmonyExitPage
> {	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(ExitPage), [typeof(int), typeof(int), typeof(int), typeof(int)]),
> 			prefix: new HarmonyMethod(typeof(HarmonyExitPage), nameof(MockConstructor))
> 		);
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(ExitPage)),
> 			prefix: new HarmonyMethod(typeof(HarmonyExitPage), nameof(MockConstructor))
> 		);
> 	}
> 
> 	static bool MockConstructor() => false;
> }
> =======
> ﻿using HarmonyLib;
> using StardewValley.Menus;
> 
> namespace Tests.HarmonyMocks;
> public class HarmonyExitPage
> {	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(ExitPage), [typeof(int), typeof(int), typeof(int), typeof(int)]),
> 			prefix: new HarmonyMethod(typeof(HarmonyExitPage), nameof(MockConstructor))
> 		);
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(ExitPage)),
> 			prefix: new HarmonyMethod(typeof(HarmonyExitPage), nameof(MockConstructor))
> 		);
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		// No static fields to reset
> 	}
> 
> 	static bool MockConstructor() => false;
> }
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyGameMenu.cs
> ```csharp
> <<<<<<< SEARCH
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley;
> using StardewValley.Menus;
> using StardewValley.Network;
> 
> namespace Tests.HarmonyMocks;
> 
> public static class HarmonyGameMenu
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(GameMenu), [typeof(int), typeof(int), typeof(bool)]),
> 			prefix: new HarmonyMethod(typeof(HarmonyGameMenu), nameof(MockConstructor))
> 		);
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(GameMenu), [typeof(bool)]),
> 			prefix: new HarmonyMethod(typeof(HarmonyGameMenu), nameof(MockConstructor))
> 		);
> 	}
> 
> 	static bool MockConstructor() => false;
> }
> =======
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley;
> using StardewValley.Menus;
> using StardewValley.Network;
> 
> namespace Tests.HarmonyMocks;
> 
> public static class HarmonyGameMenu
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(GameMenu), [typeof(int), typeof(int), typeof(bool)]),
> 			prefix: new HarmonyMethod(typeof(HarmonyGameMenu), nameof(MockConstructor))
> 		);
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(GameMenu), [typeof(bool)]),
> 			prefix: new HarmonyMethod(typeof(HarmonyGameMenu), nameof(MockConstructor))
> 		);
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		// No static fields to reset
> 	}
> 
> 	static bool MockConstructor() => false;
> }
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyGraphicsDeviceManager.cs
> ```csharp
> <<<<<<< SEARCH
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework;
> using Microsoft.Xna.Framework.Graphics;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyGraphicsDeviceManager
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(GraphicsDeviceManager), [typeof(Game)]),
> 			prefix: new HarmonyMethod(typeof(HarmonyGraphicsDeviceManager), nameof(MockConstructor))
> 		);
> 	}
> 
> 	static bool MockConstructor() => false;
> }
> =======
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework;
> using Microsoft.Xna.Framework.Graphics;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyGraphicsDeviceManager
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(GraphicsDeviceManager), [typeof(Game)]),
> 			prefix: new HarmonyMethod(typeof(HarmonyGraphicsDeviceManager), nameof(MockConstructor))
> 		);
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		// No static fields to reset
> 	}
> 
> 	static bool MockConstructor() => false;
> }
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyIClickableMenu.cs
> ```csharp
> <<<<<<< SEARCH
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley;
> using StardewValley.Menus;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyIClickableMenu
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Method(
> 				typeof(IClickableMenu),
> 				nameof(IClickableMenu.drawMouse),
> 				new [] { typeof(SpriteBatch), typeof(bool), typeof(int) }),
> 			prefix: new HarmonyMethod(typeof(HarmonyIClickableMenu), nameof(MockDrawMouse))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(IClickableMenu), nameof(IClickableMenu.drawHoverText), new []
> 			{
> 				typeof(SpriteBatch),
> 				typeof(string),
> 				typeof(SpriteFont),
> 				typeof(int),
> 				typeof(int),
> 				typeof(int),
> 				typeof(string),
> 				typeof(int),
> 				typeof(string[]),
> 				typeof(Item),
> 				typeof(int),
> 				typeof(string),
> 				typeof(int),
> 				typeof(int),
> 				typeof(int),
> 				typeof(float),
> 				typeof(CraftingRecipe),
> 				typeof(IList<Item>),
> 				typeof(Texture2D),
> 				typeof(Rectangle?),
> 				typeof(Color?),
> 				typeof(Color?),
> 				typeof(float),
> 				typeof(int),
> 				typeof(int),
> 				
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonyIClickableMenu), nameof(MockDrawHoverText))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(IClickableMenu), nameof(IClickableMenu.drawTextureBox), new []
> 			{
> 				typeof(SpriteBatch),
> 				typeof(Texture2D),
> 				typeof(Rectangle),
> 				typeof(int),
> 				typeof(int),
> 				typeof(int),
> 				typeof(int),
> 				typeof(Color),
> 				typeof(float),
> 				typeof(bool),
> 				typeof(float),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonyIClickableMenu), nameof(MockDrawTextureBox))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(IClickableMenu), "drawHorizontalPartition", new []
> 			{
> 				typeof(SpriteBatch),
> 				typeof(int),
> 				typeof(bool),
> 				typeof(int),
> 				typeof(int),
> 				typeof(int),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonyIClickableMenu), nameof(MockDrawHorizontalPartition))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(IClickableMenu), "drawVerticalPartition", new []
> 			{
> 				typeof(SpriteBatch),
> 				typeof(int),
> 				typeof(bool),
> 				typeof(int),
> 				typeof(int),
> 				typeof(int),
> 				typeof(int),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonyIClickableMenu), nameof(MockDrawVerticalPartition))
> 		);
> 
> 		DrawMouseCalls = new();
> 		DrawHoverTextCalls = new();
> 		DrawTextureBoxCalls = new();
> 		DrawHoriztonalPartitionCalls = new();
> 		DrawVerticalPartitionCalls = new();
> 	}
> 
> 	public static Dictionary<SpriteBatch, int> DrawMouseCalls;
> 	public static Dictionary<SpriteBatch, string> DrawHoverTextCalls;
> 	public static Dictionary<SpriteBatch, 
> 		List<(
> 			Texture2D texture,
> 			Rectangle sourceRect,
> 			int x,
> 			int y,
> 			int width,
> 			int height,
> 			Color color,
> 			float scale,
> 			bool drawShadow,
> 			float draw_layer
> 		)>> DrawTextureBoxCalls;
> 	
> 	public static Dictionary<SpriteBatch, 
> 		List<(
> 			int height,
> 			int yPositionOnScreen,
> 			int yPosition,
> 			bool small,
> 			int red,
> 			int green,
> 			int blue
> 		)>> DrawHoriztonalPartitionCalls;
> 	
> 	public static Dictionary<SpriteBatch, 
> 		List<(
> 			int height,
> 			int yPositionOnScreen,
> 			int xPosition,
> 			bool small,
> 			int red,
> 			int green,
> 			int blue,
> 			int heightOverride
> 		)>> DrawVerticalPartitionCalls;
> 
> 	static bool MockDrawMouse
> 	(
> 		SpriteBatch b
> 	)
> 	{
> 		DrawMouseCalls.TryAdd(b, 0);
> 		DrawMouseCalls[b] += 1;
> 
> 		return false;
> 	}
> 	
> 	static bool MockDrawHoverText
> 	(
> 		SpriteBatch b,
> 		string text
> 	)
> 	{
> 		if (!DrawHoverTextCalls.TryAdd(b, text))
> 		{
> 			DrawHoverTextCalls[b] = text;
> 		}
> 
> 		return false;
> 	}
> 	
> 	static bool MockDrawTextureBox
> 	(
> 		SpriteBatch b,
> 		Texture2D texture,
> 		Rectangle sourceRect,
> 		int x,
> 		int y,
> 		int width,
> 		int height,
> 		Color color,
> 		float scale,
> 		bool drawShadow,
> 		// ReSharper disable once InconsistentNaming
> 		float draw_layer
> 	)
> 	{
> 		#pragma warning disable CA1854
> 		if (!DrawTextureBoxCalls.ContainsKey(b))
> 		#pragma warning restore CA1854
> 		{
> 			DrawTextureBoxCalls.Add(b, []);
> 		}
> 		
> 		DrawTextureBoxCalls[b].Add((texture, sourceRect, x, y, width, height, color, scale, drawShadow, draw_layer));
> 
> 		return false;
> 	}
> 	
> 	static bool MockDrawHorizontalPartition
> 	(
> 		IClickableMenu __instance,
> 		SpriteBatch b,
> 		int yPosition,
> 		bool small,
> 		int red,
> 		int green,
> 		int blue
> 	)
> 	{
> 		#pragma warning disable CA1854
> 		if (!DrawHoriztonalPartitionCalls.ContainsKey(b))
> 		#pragma warning restore CA1854
> 		{
> 			DrawHoriztonalPartitionCalls.Add(b, []);
> 		}
> 
> 		DrawHoriztonalPartitionCalls[b].Add((__instance.height, __instance.yPositionOnScreen, yPosition, small, red, green, blue));
> 
> 		return false;
> 	}
> 	
> 	static bool MockDrawVerticalPartition
> 	(
> 		IClickableMenu __instance,
> 		SpriteBatch b,
> 		int xPosition,
> 		bool small,
> 		int red,
> 		int green,
> 		int blue,
> 		int heightOverride
> 	)
> 	{
> 		#pragma warning disable CA1854
> 		if (!DrawVerticalPartitionCalls.ContainsKey(b))
> 		#pragma warning restore CA1854
> 		{
> 			DrawVerticalPartitionCalls.Add(b, []);
> 		}
> 
> 		DrawVerticalPartitionCalls[b].Add((__instance.height, __instance.yPositionOnScreen, xPosition, small, red, green, blue, heightOverride));
> 
> 		return false;
> 	}
> }
> =======
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley;
> using StardewValley.Menus;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyIClickableMenu
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Method(
> 				typeof(IClickableMenu),
> 				nameof(IClickableMenu.drawMouse),
> 				new [] { typeof(SpriteBatch), typeof(bool), typeof(int) }),
> 			prefix: new HarmonyMethod(typeof(HarmonyIClickableMenu), nameof(MockDrawMouse))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(IClickableMenu), nameof(IClickableMenu.drawHoverText), new []
> 			{
> 				typeof(SpriteBatch),
> 				typeof(string),
> 				typeof(SpriteFont),
> 				typeof(int),
> 				typeof(int),
> 				typeof(int),
> 				typeof(string),
> 				typeof(int),
> 				typeof(string[]),
> 				typeof(Item),
> 				typeof(int),
> 				typeof(string),
> 				typeof(int),
> 				typeof(int),
> 				typeof(int),
> 				typeof(float),
> 				typeof(CraftingRecipe),
> 				typeof(IList<Item>),
> 				typeof(Texture2D),
> 				typeof(Rectangle?),
> 				typeof(Color?),
> 				typeof(Color?),
> 				typeof(float),
> 				typeof(int),
> 				typeof(int),
> 				
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonyIClickableMenu), nameof(MockDrawHoverText))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(IClickableMenu), nameof(IClickableMenu.drawTextureBox), new []
> 			{
> 				typeof(SpriteBatch),
> 				typeof(Texture2D),
> 				typeof(Rectangle),
> 				typeof(int),
> 				typeof(int),
> 				typeof(int),
> 				typeof(int),
> 				typeof(Color),
> 				typeof(float),
> 				typeof(bool),
> 				typeof(float),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonyIClickableMenu), nameof(MockDrawTextureBox))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(IClickableMenu), "drawHorizontalPartition", new []
> 			{
> 				typeof(SpriteBatch),
> 				typeof(int),
> 				typeof(bool),
> 				typeof(int),
> 				typeof(int),
> 				typeof(int),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonyIClickableMenu), nameof(MockDrawHorizontalPartition))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(IClickableMenu), "drawVerticalPartition", new []
> 			{
> 				typeof(SpriteBatch),
> 				typeof(int),
> 				typeof(bool),
> 				typeof(int),
> 				typeof(int),
> 				typeof(int),
> 				typeof(int),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonyIClickableMenu), nameof(MockDrawVerticalPartition))
> 		);
> 
> 		DrawMouseCalls = new();
> 		DrawHoverTextCalls = new();
> 		DrawTextureBoxCalls = new();
> 		DrawHoriztonalPartitionCalls = new();
> 		DrawVerticalPartitionCalls = new();
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		DrawMouseCalls.Clear();
> 		DrawHoverTextCalls.Clear();
> 		DrawTextureBoxCalls.Clear();
> 		DrawHoriztonalPartitionCalls.Clear();
> 		DrawVerticalPartitionCalls.Clear();
> 	}
> 
> 	public static Dictionary<SpriteBatch, int> DrawMouseCalls;
> 	public static Dictionary<SpriteBatch, string> DrawHoverTextCalls;
> 	public static Dictionary<SpriteBatch, 
> 		List<(
> 			Texture2D texture,
> 			Rectangle sourceRect,
> 			int x,
> 			int y,
> 			int width,
> 			int height,
> 			Color color,
> 			float scale,
> 			bool drawShadow,
> 			float draw_layer
> 		)>> DrawTextureBoxCalls;
> 	
> 	public static Dictionary<SpriteBatch, 
> 		List<(
> 			int height,
> 			int yPositionOnScreen,
> 			int yPosition,
> 			bool small,
> 			int red,
> 			int green,
> 			int blue
> 		)>> DrawHoriztonalPartitionCalls;
> 	
> 	public static Dictionary<SpriteBatch, 
> 		List<(
> 			int height,
> 			int yPositionOnScreen,
> 			int xPosition,
> 			bool small,
> 			int red,
> 			int green,
> 			int blue,
> 			int heightOverride
> 		)>> DrawVerticalPartitionCalls;
> 
> 	static bool MockDrawMouse
> 	(
> 		SpriteBatch b
> 	)
> 	{
> 		DrawMouseCalls.TryAdd(b, 0);
> 		DrawMouseCalls[b] += 1;
> 
> 		return false;
> 	}
> 	
> 	static bool MockDrawHoverText
> 	(
> 		SpriteBatch b,
> 		string text
> 	)
> 	{
> 		if (!DrawHoverTextCalls.TryAdd(b, text))
> 		{
> 			DrawHoverTextCalls[b] = text;
> 		}
> 
> 		return false;
> 	}
> 	
> 	static bool MockDrawTextureBox
> 	(
> 		SpriteBatch b,
> 		Texture2D texture,
> 		Rectangle sourceRect,
> 		int x,
> 		int y,
> 		int width,
> 		int height,
> 		Color color,
> 		float scale,
> 		bool drawShadow,
> 		// ReSharper disable once InconsistentNaming
> 		float draw_layer
> 	)
> 	{
> 		#pragma warning disable CA1854
> 		if (!DrawTextureBoxCalls.ContainsKey(b))
> 		#pragma warning restore CA1854
> 		{
> 			DrawTextureBoxCalls.Add(b, []);
> 		}
> 		
> 		DrawTextureBoxCalls[b].Add((texture, sourceRect, x, y, width, height, color, scale, drawShadow, draw_layer));
> 
> 		return false;
> 	}
> 	
> 	static bool MockDrawHorizontalPartition
> 	(
> 		IClickableMenu __instance,
> 		SpriteBatch b,
> 		int yPosition,
> 		bool small,
> 		int red,
> 		int green,
> 		int blue
> 	)
> 	{
> 		#pragma warning disable CA1854
> 		if (!DrawHoriztonalPartitionCalls.ContainsKey(b))
> 		#pragma warning restore CA1854
> 		{
> 			DrawHoriztonalPartitionCalls.Add(b, []);
> 		}
> 
> 		DrawHoriztonalPartitionCalls[b].Add((__instance.height, __instance.yPositionOnScreen, yPosition, small, red, green, blue));
> 
> 		return false;
> 	}
> 	
> 	static bool MockDrawVerticalPartition
> 	(
> 		IClickableMenu __instance,
> 		SpriteBatch b,
> 		int xPosition,
> 		bool small,
> 		int red,
> 		int green,
> 		int blue,
> 		int heightOverride
> 	)
> 	{
> 		#pragma warning disable CA1854
> 		if (!DrawVerticalPartitionCalls.ContainsKey(b))
> 		#pragma warning restore CA1854
> 		{
> 			DrawVerticalPartitionCalls.Add(b, []);
> 		}
> 
> 		DrawVerticalPartitionCalls[b].Add((__instance.height, __instance.yPositionOnScreen, xPosition, small, red, green, blue, heightOverride));
> 
> 		return false;
> 	}
> }
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyItem.cs
> ```csharp
> <<<<<<< SEARCH
> ﻿using System.Globalization;
> using HarmonyLib;
> using Microsoft.Xna.Framework;
> using Microsoft.Xna.Framework.Graphics;
> using Netcode;
> using StardewValley;
> using Object = StardewValley.Object;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyItem
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Item), nameof(Item.Category)),
> 			prefix: new HarmonyMethod(typeof(HarmonyItem), nameof(MockGetCategory))
> 		);
> 		harmony.Patch(
> 			AccessTools.PropertySetter(typeof(Item), nameof(Item.Category)),
> 			prefix: new HarmonyMethod(typeof(HarmonyItem), nameof(MockSetCategory))
> 		);
> 
> 		CategoryMapping = new();
> 	}
> 
> 	public static Dictionary<Item, int> CategoryMapping;
> 
> 	static bool MockGetCategory(
> 		ref Object __instance,
> 		ref int __result
> 	)
> 	{
> 		__result = CategoryMapping.GetValueOrDefault(__instance, -1);
> 		return false;
> 	}
> 	
> 	static bool MockSetCategory(
> 		ref Object __instance,
> 		int value
> 	)
> 	{
> 		CategoryMapping.TryAdd(__instance, value);
> 		CategoryMapping[__instance] = value;
> 		return false;
> 	}
> 
> }
> =======
> ﻿using System.Globalization;
> using HarmonyLib;
> using Microsoft.Xna.Framework;
> using Microsoft.Xna.Framework.Graphics;
> using Netcode;
> using StardewValley;
> using Object = StardewValley.Object;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyItem
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Item), nameof(Item.Category)),
> 			prefix: new HarmonyMethod(typeof(HarmonyItem), nameof(MockGetCategory))
> 		);
> 		harmony.Patch(
> 			AccessTools.PropertySetter(typeof(Item), nameof(Item.Category)),
> 			prefix: new HarmonyMethod(typeof(HarmonyItem), nameof(MockSetCategory))
> 		);
> 
> 		CategoryMapping = new();
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		CategoryMapping.Clear();
> 	}
> 
> 	public static Dictionary<Item, int> CategoryMapping;
> 
> 	static bool MockGetCategory(
> 		ref Object __instance,
> 		ref int __result
> 	)
> 	{
> 		__result = CategoryMapping.GetValueOrDefault(__instance, -1);
> 		return false;
> 	}
> 	
> 	static bool MockSetCategory(
> 		ref Object __instance,
> 		int value
> 	)
> 	{
> 		CategoryMapping.TryAdd(__instance, value);
> 		CategoryMapping[__instance] = value;
> 		return false;
> 	}
> 
> }
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyLetterViewMenu.cs
> ```csharp
> <<<<<<< SEARCH
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley.Menus;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyLetterViewMenu
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(LetterViewerMenu), [typeof(int)]),
> 			prefix: new HarmonyMethod(typeof(HarmonyLetterViewMenu), nameof(MockConstructor))
> 		);
> 	}
> 
> 	static bool MockConstructor() => false;
> }
> =======
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley.Menus;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyLetterViewMenu
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(LetterViewerMenu), [typeof(int)]),
> 			prefix: new HarmonyMethod(typeof(HarmonyLetterViewMenu), nameof(MockConstructor))
> 		);
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		// No static fields to reset
> 	}
> 
> 	static bool MockConstructor() => false;
> }
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyLocalizedContentManager.cs
> ```csharp
> <<<<<<< SEARCH
> ﻿using System.Globalization;
> using HarmonyLib;
> using StardewValley;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyLocalizedContentManager
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(LocalizedContentManager), new []
> 			{
> 				typeof(IServiceProvider), 
> 				typeof(string),
> 				typeof(CultureInfo),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonyLocalizedContentManager), nameof(MockConstructor))
> 		);
> 
> 		harmony.Patch(
> 			typeof(LocalizedContentManager).GetMethods()
> 				.First(m => m.Name == nameof(LocalizedContentManager.Load) && m.GetParameters().Length == 1)
> 				.MakeGenericMethod(typeof(object)),
> 			prefix: new HarmonyMethod(typeof(HarmonyLocalizedContentManager), nameof(MockLoad))
> 		);
> 	}
> 
> 	static bool MockConstructor() => false;
> 	
> 	public static object LoadResult { get; set; }
> 	static bool MockLoad(ref object __result)
> 	{
> 		__result = LoadResult;
> 		return false;
> 	}
> }
> =======
> ﻿using System.Globalization;
> using HarmonyLib;
> using StardewValley;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyLocalizedContentManager
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(LocalizedContentManager), new []
> 			{
> 				typeof(IServiceProvider), 
> 				typeof(string),
> 				typeof(CultureInfo),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonyLocalizedContentManager), nameof(MockConstructor))
> 		);
> 
> 		harmony.Patch(
> 			typeof(LocalizedContentManager).GetMethods()
> 				.First(m => m.Name == nameof(LocalizedContentManager.Load) && m.GetParameters().Length == 1)
> 				.MakeGenericMethod(typeof(object)),
> 			prefix: new HarmonyMethod(typeof(HarmonyLocalizedContentManager), nameof(MockLoad))
> 		);
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		LoadResult = null;
> 	}
> 
> 	static bool MockConstructor() => false;
> 	
> 	public static object LoadResult { get; set; }
> 	static bool MockLoad(ref object __result)
> 	{
> 		__result = LoadResult;
> 		return false;
> 	}
> }
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyMapPage.cs
> ```csharp
> <<<<<<< SEARCH
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley.Menus;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyMapPage
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(MapPage), [typeof(int), typeof(int), typeof(int), typeof(int)]),
> 			prefix: new HarmonyMethod(typeof(HarmonyMapPage), nameof(MockConstructor))
> 		);
> 	}
> 
> 	static bool MockConstructor() => false;
> }
> =======
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley.Menus;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyMapPage
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(MapPage), [typeof(int), typeof(int), typeof(int), typeof(int)]),
> 			prefix: new HarmonyMethod(typeof(HarmonyMapPage), nameof(MockConstructor))
> 		);
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		// No static fields to reset
> 	}
> 
> 	static bool MockConstructor() => false;
> }
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyOptions.cs
> ```csharp
> <<<<<<< SEARCH
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley;
> using StardewValley.Menus;
> using StardewValley.Network;
> 
> namespace Tests.HarmonyMocks;
> 
> public static class HarmonyOptions
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(Options)),
> 			prefix: new HarmonyMethod(typeof(HarmonyOptions), nameof(MockConstructor))
> 		);
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Options), nameof(Options.uiScale)),
> 			prefix: new HarmonyMethod(typeof(HarmonyOptions), nameof(MockGetUiScale))
> 		);
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Options), nameof(Options.zoomLevel)),
> 			prefix: new HarmonyMethod(typeof(HarmonyOptions), nameof(MockGetZoomLevel))
> 		);
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Options), nameof(Options.hardwareCursor)),
> 			prefix: new HarmonyMethod(typeof(HarmonyOptions), nameof(MockGetHardwareCursor))
> 		);
> 
> 		GetUiScaleResult = 1f;
> 		GetZoomLevelResult = 1f;
> 		GetHardwareCursor = false;
> 	}
> 
> 	public static float GetUiScaleResult { get; set; } = 1f;
> 	public static float GetZoomLevelResult { get; set; } = 1f;
> 	public static bool GetHardwareCursor { get; set; } = false;
> 	
> 	static bool MockConstructor() => false;
> 
> 	static bool MockGetUiScale(ref float __result)
> 	{
> 		__result = GetUiScaleResult;
> 		return false;
> 	}
> 	static bool MockGetZoomLevel(ref float __result)
> 	{
> 		__result = GetZoomLevelResult;
> 		return false;
> 	}
> 	static bool MockGetHardwareCursor(ref bool __result)
> 	{
> 		__result = GetHardwareCursor;
> 		return false;
> 	}
> }
> =======
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley;
> using StardewValley.Menus;
> using StardewValley.Network;
> 
> namespace Tests.HarmonyMocks;
> 
> public static class HarmonyOptions
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(Options)),
> 			prefix: new HarmonyMethod(typeof(HarmonyOptions), nameof(MockConstructor))
> 		);
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Options), nameof(Options.uiScale)),
> 			prefix: new HarmonyMethod(typeof(HarmonyOptions), nameof(MockGetUiScale))
> 		);
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Options), nameof(Options.zoomLevel)),
> 			prefix: new HarmonyMethod(typeof(HarmonyOptions), nameof(MockGetZoomLevel))
> 		);
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Options), nameof(Options.hardwareCursor)),
> 			prefix: new HarmonyMethod(typeof(HarmonyOptions), nameof(MockGetHardwareCursor))
> 		);
> 
> 		GetUiScaleResult = 1f;
> 		GetZoomLevelResult = 1f;
> 		GetHardwareCursor = false;
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		GetUiScaleResult = 1f;
> 		GetZoomLevelResult = 1f;
> 		GetHardwareCursor = false;
> 	}
> 
> 	public static float GetUiScaleResult { get; set; } = 1f;
> 	public static float GetZoomLevelResult { get; set; } = 1f;
> 	public static bool GetHardwareCursor { get; set; } = false;
> 	
> 	static bool MockConstructor() => false;
> 
> 	static bool MockGetUiScale(ref float __result)
> 	{
> 		__result = GetUiScaleResult;
> 		return false;
> 	}
> 	static bool MockGetZoomLevel(ref float __result)
> 	{
> 		__result = GetZoomLevelResult;
> 		return false;
> 	}
> 	static bool MockGetHardwareCursor(ref bool __result)
> 	{
> 		__result = GetHardwareCursor;
> 		return false;
> 	}
> }
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyOptionsCheckbox.cs
> ```csharp
> <<<<<<< SEARCH
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley.Menus;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyOptionsCheckbox
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(OptionsCheckbox), new []
> 			{
> 				typeof(string), 
> 				typeof(int),
> 				typeof(int),
> 				typeof(int),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonyOptionsCheckbox), nameof(MockConstructor))
> 		);
> 
> 		harmony.Patch
> 			(
> 				AccessTools.Method(typeof(OptionsCheckbox), nameof(OptionsCheckbox.draw)),
> 				prefix: new HarmonyMethod(typeof(HarmonyOptionsCheckbox), nameof(MockDraw))
> 			);
> 
> 		ConstructorCalls = new();
> 		DrawCalls = new();
> 	}
> 
> 	public static Dictionary<OptionsCheckbox, List<(string label, int whichOption, int x, int y)>> ConstructorCalls;
> 	public static Dictionary<OptionsCheckbox, int> DrawCalls;
> 	
> 	static bool MockConstructor
> 		(
> 			OptionsCheckbox __instance,
> 			string label,
> 			int whichOption,
> 			int x,
> 			int y
> 		)
> 	{
> 		__instance.bounds = new Rectangle(x, y, 0, 0);
> 		if (!ConstructorCalls.ContainsKey(__instance))
> 		{
> 			ConstructorCalls.Add(__instance, []);
> 		}
> 		ConstructorCalls[__instance].Add((label, whichOption, x, y));
> 		return false;
> 	}
> 	
> 	static bool MockDraw(OptionsCheckbox __instance)
> 	{
> 		DrawCalls.TryAdd(__instance, 0);
> 		DrawCalls[__instance]++;
> 		return false;
> 	}
> }
> =======
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley.Menus;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyOptionsCheckbox
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(OptionsCheckbox), new []
> 			{
> 				typeof(string), 
> 				typeof(int),
> 				typeof(int),
> 				typeof(int),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonyOptionsCheckbox), nameof(MockConstructor))
> 		);
> 
> 		harmony.Patch
> 			(
> 				AccessTools.Method(typeof(OptionsCheckbox), nameof(OptionsCheckbox.draw)),
> 				prefix: new HarmonyMethod(typeof(HarmonyOptionsCheckbox), nameof(MockDraw))
> 			);
> 
> 		ConstructorCalls = new();
> 		DrawCalls = new();
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		ConstructorCalls.Clear();
> 		DrawCalls.Clear();
> 	}
> 
> 	public static Dictionary<OptionsCheckbox, List<(string label, int whichOption, int x, int y)>> ConstructorCalls;
> 	public static Dictionary<OptionsCheckbox, int> DrawCalls;
> 	
> 	static bool MockConstructor
> 		(
> 			OptionsCheckbox __instance,
> 			string label,
> 			int whichOption,
> 			int x,
> 			int y
> 		)
> 	{
> 		__instance.bounds = new Rectangle(x, y, 0, 0);
> 		if (!ConstructorCalls.ContainsKey(__instance))
> 		{
> 			ConstructorCalls.Add(__instance, []);
> 		}
> 		ConstructorCalls[__instance].Add((label, whichOption, x, y));
> 		return false;
> 	}
> 	
> 	static bool MockDraw(OptionsCheckbox __instance)
> 	{
> 		DrawCalls.TryAdd(__instance, 0);
> 		DrawCalls[__instance]++;
> 		return false;
> 	}
> }
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyOptionsDropDown.cs
> ```csharp
> <<<<<<< SEARCH
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley.Menus;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyOptionsDropDown
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(OptionsDropDown), new []
> 			{
> 				typeof(string), 
> 				typeof(int),
> 				typeof(int),
> 				typeof(int)
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonyOptionsDropDown), nameof(MockConstructor))
> 		);
> 
> 		harmony.Patch
> 			(
> 				AccessTools.Method(typeof(OptionsDropDown), nameof(OptionsDropDown.RecalculateBounds)),
> 				prefix: new HarmonyMethod(typeof(HarmonyOptionsDropDown), nameof(MockRecalculateBounds))
> 			);
> 		
> 		harmony.Patch
> 			(
> 				AccessTools.Method(typeof(OptionsDropDown), nameof(OptionsDropDown.draw)),
> 				prefix: new HarmonyMethod(typeof(HarmonyOptionsDropDown), nameof(MockDraw))
> 			);
> 
> 		ConstructorCalls = new();
> 		RecalculateCalls = new();
> 		DrawCalls = new();
> 	}
> 
> 	public static Dictionary<OptionsDropDown, List<(string label, int whichOption, int x, int y)>> ConstructorCalls;
> 	public static Dictionary<OptionsDropDown, int> RecalculateCalls;
> 	public static Dictionary<OptionsDropDown, int> DrawCalls;
> 	
> 	static bool MockConstructor
> 		(
> 			OptionsDropDown __instance,
> 			string label,
> 			int whichOption,
> 			int x,
> 			int y
> 		)
> 	{
> 		__instance.bounds = new Rectangle(x, y, 0, 0);
> 		if (!ConstructorCalls.ContainsKey(__instance))
> 		{
> 			ConstructorCalls.Add(__instance, []);
> 		}
> 		ConstructorCalls[__instance].Add((label, whichOption, x, y));
> 		return false;
> 	}
> 
> 	static bool MockRecalculateBounds(OptionsDropDown __instance)
> 	{
> 		RecalculateCalls.TryAdd(__instance, 0);
> 		RecalculateCalls[__instance]++;
> 		return false;
> 	}
> 	
> 	static bool MockDraw(OptionsDropDown __instance)
> 	{
> 		DrawCalls.TryAdd(__instance, 0);
> 		DrawCalls[__instance]++;
> 		return false;
> 	}
> }
> =======
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley.Menus;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyOptionsDropDown
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(OptionsDropDown), new []
> 			{
> 				typeof(string), 
> 				typeof(int),
> 				typeof(int),
> 				typeof(int)
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonyOptionsDropDown), nameof(MockConstructor))
> 		);
> 
> 		harmony.Patch
> 			(
> 				AccessTools.Method(typeof(OptionsDropDown), nameof(OptionsDropDown.RecalculateBounds)),
> 				prefix: new HarmonyMethod(typeof(HarmonyOptionsDropDown), nameof(MockRecalculateBounds))
> 			);
> 		
> 		harmony.Patch
> 			(
> 				AccessTools.Method(typeof(OptionsDropDown), nameof(OptionsDropDown.draw)),
> 				prefix: new HarmonyMethod(typeof(HarmonyOptionsDropDown), nameof(MockDraw))
> 			);
> 
> 		ConstructorCalls = new();
> 		RecalculateCalls = new();
> 		DrawCalls = new();
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		ConstructorCalls.Clear();
> 		RecalculateCalls.Clear();
> 		DrawCalls.Clear();
> 	}
> 
> 	public static Dictionary<OptionsDropDown, List<(string label, int whichOption, int x, int y)>> ConstructorCalls;
> 	public static Dictionary<OptionsDropDown, int> RecalculateCalls;
> 	public static Dictionary<OptionsDropDown, int> DrawCalls;
> 	
> 	static bool MockConstructor
> 		(
> 			OptionsDropDown __instance,
> 			string label,
> 			int whichOption,
> 			int x,
> 			int y
> 		)
> 	{
> 		__instance.bounds = new Rectangle(x, y, 0, 0);
> 		if (!ConstructorCalls.ContainsKey(__instance))
> 		{
> 			ConstructorCalls.Add(__instance, []);
> 		}
> 		ConstructorCalls[__instance].Add((label, whichOption, x, y));
> 		return false;
> 	}
> 
> 	static bool MockRecalculateBounds(OptionsDropDown __instance)
> 	{
> 		RecalculateCalls.TryAdd(__instance, 0);
> 		RecalculateCalls[__instance]++;
> 		return false;
> 	}
> 	
> 	static bool MockDraw(OptionsDropDown __instance)
> 	{
> 		DrawCalls.TryAdd(__instance, 0);
> 		DrawCalls[__instance]++;
> 		return false;
> 	}
> }
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyOptionsTextEntry.cs
> ```csharp
> <<<<<<< SEARCH
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework;
> using StardewValley.Menus;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyOptionsTextEntry
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(OptionsTextEntry), new []
> 			{
> 				typeof(string), 
> 				typeof(int),
> 				typeof(int),
> 				typeof(int),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonyOptionsTextEntry), nameof(MockConstructor))
> 		);
> 
> 		harmony.Patch
> 			(
> 				AccessTools.Method(typeof(OptionsTextEntry), nameof(OptionsTextEntry.draw)),
> 				prefix: new HarmonyMethod(typeof(HarmonyOptionsTextEntry), nameof(MockDraw))
> 			);
> 
> 		ConstructorCalls = new();
> 		DrawCalls = new();
> 	}
> 
> 	public static Dictionary<OptionsTextEntry, List<(string label, int whichOption, int x, int y)>> ConstructorCalls;
> 	public static Dictionary<OptionsTextEntry, int> DrawCalls;
> 	
> 	static bool MockConstructor
> 		(
> 			OptionsTextEntry __instance,
> 			string label,
> 			int whichOption,
> 			int x,
> 			int y
> 		)
> 	{
> 		__instance.bounds = new Rectangle(x, y, 0, 0);
> 		if (!ConstructorCalls.ContainsKey(__instance))
> 		{
> 			ConstructorCalls.Add(__instance, []);
> 		}
> 		ConstructorCalls[__instance].Add((label, whichOption, x, y));
> 		__instance.textBox = new TextBox(null, null, null, Color.Transparent);
> 		return false;
> 	}
> 	
> 	static bool MockDraw(OptionsTextEntry __instance)
> 	{
> 		DrawCalls.TryAdd(__instance, 0);
> 		DrawCalls[__instance]++;
> 		return false;
> 	}
> }
> =======
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework;
> using StardewValley.Menus;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyOptionsTextEntry
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(OptionsTextEntry), new []
> 			{
> 				typeof(string), 
> 				typeof(int),
> 				typeof(int),
> 				typeof(int),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonyOptionsTextEntry), nameof(MockConstructor))
> 		);
> 
> 		harmony.Patch
> 			(
> 				AccessTools.Method(typeof(OptionsTextEntry), nameof(OptionsTextEntry.draw)),
> 				prefix: new HarmonyMethod(typeof(HarmonyOptionsTextEntry), nameof(MockDraw))
> 			);
> 
> 		ConstructorCalls = new();
> 		DrawCalls = new();
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		ConstructorCalls.Clear();
> 		DrawCalls.Clear();
> 	}
> 
> 	public static Dictionary<OptionsTextEntry, List<(string label, int whichOption, int x, int y)>> ConstructorCalls;
> 	public static Dictionary<OptionsTextEntry, int> DrawCalls;
> 	
> 	static bool MockConstructor
> 		(
> 			OptionsTextEntry __instance,
> 			string label,
> 			int whichOption,
> 			int x,
> 			int y
> 		)
> 	{
> 		__instance.bounds = new Rectangle(x, y, 0, 0);
> 		if (!ConstructorCalls.ContainsKey(__instance))
> 		{
> 			ConstructorCalls.Add(__instance, []);
> 		}
> 		ConstructorCalls[__instance].Add((label, whichOption, x, y));
> 		__instance.textBox = new TextBox(null, null, null, Color.Transparent);
> 		return false;
> 	}
> 	
> 	static bool MockDraw(OptionsTextEntry __instance)
> 	{
> 		DrawCalls.TryAdd(__instance, 0);
> 		DrawCalls[__instance]++;
> 		return false;
> 	}
> }
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyTextBox.cs
> ```csharp
> <<<<<<< SEARCH
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley.Menus;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyTextBox
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(TextBox), new []
> 			{
> 				typeof(Texture2D),
> 				typeof(Texture2D),
> 				typeof(SpriteFont),
> 				typeof(Color)
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonyTextBox), nameof(MockConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			original: AccessTools.PropertySetter(typeof(TextBox), nameof(TextBox.Selected)),
> 			prefix: new HarmonyMethod(typeof(HarmonyTextBox), nameof(MockSelected))
> 		);
> 
> 		harmony.Patch(
> 			original: AccessTools.PropertyGetter(typeof(TextBox), nameof(TextBox.Selected)), 
> 			prefix: new HarmonyMethod(typeof(HarmonyTextBox), nameof(MockSelected))
> 		);
> 
> 		harmony.Patch(
> 			original: AccessTools.Method(typeof(TextBox), nameof(TextBox.SelectMe)),
> 			prefix: new HarmonyMethod(typeof(HarmonyTextBox), nameof(MockSelectMe))
> 		);
> 
> 		harmony.Patch(
> 			original: AccessTools.Method(typeof(TextBox), nameof(TextBox.Update)),
> 			prefix: new HarmonyMethod(typeof(HarmonyTextBox), nameof(MockUpdate))
> 		);
> 	}
> 
> 	static bool MockConstructor() => false;
> 
> 	private static bool MockSelected() => false;
> 	private static bool MockSelectMe() => false;
> 	private static bool MockUpdate() => false;
> }
> =======
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework;
> using Microsoft.Xna.Framework.Graphics;
> using StardewValley.Menus;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyTextBox
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(TextBox), new []
> 			{
> 				typeof(Texture2D),
> 				typeof(Texture2D),
> 				typeof(SpriteFont),
> 				typeof(Color)
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonyTextBox), nameof(MockConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			original: AccessTools.PropertySetter(typeof(TextBox), nameof(TextBox.Selected)),
> 			prefix: new HarmonyMethod(typeof(HarmonyTextBox), nameof(MockSelected))
> 		);
> 
> 		harmony.Patch(
> 			original: AccessTools.PropertyGetter(typeof(TextBox), nameof(TextBox.Selected)), 
> 			prefix: new HarmonyMethod(typeof(HarmonyTextBox), nameof(MockSelected))
> 		);
> 
> 		harmony.Patch(
> 			original: AccessTools.Method(typeof(TextBox), nameof(TextBox.SelectMe)),
> 			prefix: new HarmonyMethod(typeof(HarmonyTextBox), nameof(MockSelectMe))
> 		);
> 
> 		harmony.Patch(
> 			original: AccessTools.Method(typeof(TextBox), nameof(TextBox.Update)),
> 			prefix: new HarmonyMethod(typeof(HarmonyTextBox), nameof(MockUpdate))
> 		);
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		// No static fields to reset
> 	}
> 
> 	static bool MockConstructor() => false;
> 
> 	private static bool MockSelected() => false;
> 	private static bool MockSelectMe() => false;
> 	private static bool MockUpdate() => false;
> }
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyTexture2D.cs
> ```csharp
> <<<<<<< SEARCH
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework;
> using Microsoft.Xna.Framework.Graphics;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyTexture2D
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(Texture2D), new []
> 			{
> 				typeof(GraphicsDevice), 
> 				typeof(int),
> 				typeof(int),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonyTexture2D), nameof(MockConstructor))
> 		);
> 
> 		harmony.Patch(
> 			typeof(Texture2D).GetMethods()
> 				.First(m => m.Name == nameof(Texture2D.SetData) && m.GetParameters().Length == 1)
> 				.MakeGenericMethod(typeof(Color)),
> 			prefix: new HarmonyMethod(typeof(HarmonyTexture2D), nameof(MockConstructor))
> 		);
> 	}
> 
> 	static bool MockConstructor() => false;
> }
> =======
> ﻿using HarmonyLib;
> using Microsoft.Xna.Framework;
> using Microsoft.Xna.Framework.Graphics;
> 
> namespace Tests.HarmonyMocks;
> 
> public class HarmonyTexture2D
> {
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(Texture2D), new []
> 			{
> 				typeof(GraphicsDevice), 
> 				typeof(int),
> 				typeof(int),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonyTexture2D), nameof(MockConstructor))
> 		);
> 
> 		harmony.Patch(
> 			typeof(Texture2D).GetMethods()
> 				.First(m => m.Name == nameof(Texture2D.SetData) && m.GetParameters().Length == 1)
> 				.MakeGenericMethod(typeof(Color)),
> 			prefix: new HarmonyMethod(typeof(HarmonyTexture2D), nameof(MockConstructor))
> 		);
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		// No static fields to reset
> 	}
> 
> 	static bool MockConstructor() => false;
> }
> >>>>>>> REPLACE
> ```
> 
> Now all the Harmony mock classes have TearDown methods that reset their static fields to ensure tests don't interfere with each other. This completes the implementation of the plan we outlined earlier.
> 
> > Tokens: 30k sent, 11k received. Cost: $0.25 message, $0.59 session.  
> > Applied edit to Tests/HarmonyMocks/HarmonyItem.cs  
> > Applied edit to Tests/HarmonyMocks/HarmonyOptionsCheckbox.cs  
> > Applied edit to Tests/HarmonyMocks/HarmonyTexture2D.cs  
> > Applied edit to Tests/HarmonyMocks/HarmonyOptionsTextEntry.cs  
> > Applied edit to Tests/HarmonyMocks/HarmonyClickableTextureComponent.cs  
> > Applied edit to Tests/HarmonyMocks/HarmonyGraphicsDeviceManager.cs  
> > Applied edit to Tests/HarmonyMocks/HarmonyIClickableMenu.cs  
> > Applied edit to Tests/HarmonyMocks/HarmonyLocalizedContentManager.cs  
> > Applied edit to Tests/HarmonyMocks/HarmonyTextBox.cs  
> > Applied edit to Tests/HarmonyMocks/HarmonyMapPage.cs  
> > Applied edit to Tests/HarmonyMocks/HarmonyLetterViewMenu.cs  
> > Applied edit to Tests/HarmonyMocks/HarmonyOptionsDropDown.cs  
> > Applied edit to Tests/HarmonyMocks/HarmonyCollectionsPage.cs  
> > Applied edit to Tests/HarmonyMocks/HarmonyOptions.cs  
> > Applied edit to Tests/HarmonyMocks/HarmonyGameMenu.cs  
> > Applied edit to Tests/HarmonyMocks/HarmonyExitPage.cs  
> > Commit d3a24b2 feat: implement TearDown methods for Harmony mock classes
> 
> This commit adds TearDown methods to all Harmony mock classes to reset static fields and ensure test isolation. The changes include:
> 
> - Added TearDown() method to classes with static collections or state
> - Cleared static dictionaries and reset static properties
> - Ensured no state leaks between tests
> - Maintained consistent pattern across all mock classes
> 
> The implementation ensures that each test starts with a clean slate by resetting any static fields or collections that might have been modified during previous test runs.  
> > You can use /undo to undo and discard each aider commit.

> **Prompt:**
>
> HarmonyFarmer.TearDown();
> HarmonyGame.TearDown();
> HarmonyFarmerCollection.TearDown();
> HarmonyFarmerTeam.TearDown();
> HarmonyFarm.TearDown();
> HarmonyObject.TearDown();
> HarmonyModMessageReceivedEventArgs.TearDown();
> HarmonySpriteFont.TearDown();
> HarmonyUtility.TearDown();
> HarmonySpriteBatch.TearDown(); are not implemented, implement those as well
> I'll implement the missing TearDown methods for the Harmony mock classes you mentioned. Here are the changes:
> 
> Tests/HarmonyMocks/HarmonyFarm.cs
> ```csharp
> <<<<<<< SEARCH
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(Farm)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarm), nameof(MockConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Farm), nameof(Farm.getShippingBin)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarm), nameof(MockGetShippingBin))
> 		);
> 	}
> =======
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(Farm)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarm), nameof(MockConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Farm), nameof(Farm.getShippingBin)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarm), nameof(MockGetShippingBin))
> 		);
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		GetShippingBinDictionary.Clear();
> 	}
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyFarmer.cs
> ```csharp
> <<<<<<< SEARCH
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(Farmer)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmer), nameof(MockConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Farmer), nameof(Farmer.UniqueMultiplayerID)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmer), nameof(MockUniqueMultiplayerID))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Farmer), nameof(Farmer.IsMainPlayer)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmer), nameof(MockIsMainPlayer))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Farmer), nameof(Farmer.team)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmer), nameof(MockGetTeam))
> 		);
> 
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Farmer), nameof(Farmer.Gender)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmer), nameof(MockGetGender))
> 
> 		);
> 		
> 		UniqueMultiplayerIdDictionary.Clear();
> 	}
> =======
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(Farmer)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmer), nameof(MockConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Farmer), nameof(Farmer.UniqueMultiplayerID)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmer), nameof(MockUniqueMultiplayerID))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Farmer), nameof(Farmer.IsMainPlayer)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmer), nameof(MockIsMainPlayer))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Farmer), nameof(Farmer.team)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmer), nameof(MockGetTeam))
> 		);
> 
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Farmer), nameof(Farmer.Gender)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmer), nameof(MockGetGender))
> 
> 		);
> 		
> 		UniqueMultiplayerIdDictionary.Clear();
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		UniqueMultiplayerIdDictionary.Clear();
> 		IsMainPlayerDictionary.Clear();
> 		FarmerTeamDictionary.Clear();
> 	}
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyFarmerCollection.cs
> ```csharp
> <<<<<<< SEARCH
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Method(typeof(FarmerCollection), nameof(FarmerCollection.GetEnumerator)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmerCollection), nameof(MockGetEnumerator))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(FarmerCollection.Enumerator), [typeof(GameLocation)]),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmerCollection), nameof(MockEnumeratorConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(FarmerCollection.Enumerator), nameof(FarmerCollection.Enumerator.Current)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmerCollection), nameof(MockEnumeratorCurrent))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(FarmerCollection.Enumerator), nameof(FarmerCollection.Enumerator.MoveNext)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmerCollection), nameof(MockEnumeratorMoveNext))
> 		);
> 	}
> =======
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Method(typeof(FarmerCollection), nameof(FarmerCollection.GetEnumerator)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmerCollection), nameof(MockGetEnumerator))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(FarmerCollection.Enumerator), [typeof(GameLocation)]),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmerCollection), nameof(MockEnumeratorConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(FarmerCollection.Enumerator), nameof(FarmerCollection.Enumerator.Current)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmerCollection), nameof(MockEnumeratorCurrent))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(FarmerCollection.Enumerator), nameof(FarmerCollection.Enumerator.MoveNext)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmerCollection), nameof(MockEnumeratorMoveNext))
> 		);
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		CollectionEnumerator = null;
> 	}
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyFarmerTeam.cs
> ```csharp
> <<<<<<< SEARCH
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(FarmerTeam)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmerTeam), nameof(MockConstructor))
> 		);
> 	}
> =======
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(FarmerTeam)),
> 			prefix: new HarmonyMethod(typeof(HarmonyFarmerTeam), nameof(MockConstructor))
> 		);
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		// No static fields to reset
> 	}
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyGame.cs
> ```csharp
> <<<<<<< SEARCH
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Game1), nameof(Game1.player)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetPlayer))
> 		);
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Game1), nameof(Game1.activeClickableMenu)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetActiveClickableMenu))
> 		);
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Game1), nameof(Game1.options)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetOptions))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Game1), nameof(Game1.getOnlineFarmers)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetOnlineFarmers))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Game1), nameof(Game1.getAllFarmers)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetAllFarmers))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Game1), nameof(Game1.getFarm)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetFarm))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Game1), nameof(Game1.getSourceRectForStandardTileSheet)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetSourceRectForStandardTileSheet))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Game1), nameof(Game1.playSound), new []{typeof(string), typeof(int?)}),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockPlaySound))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(
> 				typeof(Game1), 
> 				nameof(Game1.drawDialogueBox), 
> 				new []
> 				{
> 					typeof(int),
> 					typeof(int),
> 					typeof(int),
> 					typeof(int),
> 					typeof(bool),
> 					typeof(bool),
> 					typeof(string),
> 					typeof(bool),
> 					typeof(bool),
> 					typeof(int),
> 					typeof(int),
> 					typeof(int)
> 				}
> 			),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockDrawDialogueBox))
> 		);
> 		DrawDialogueBoxCalls.Clear();
> 	}
> =======
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Game1), nameof(Game1.player)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetPlayer))
> 		);
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Game1), nameof(Game1.activeClickableMenu)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetActiveClickableMenu))
> 		);
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Game1), nameof(Game1.options)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetOptions))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Game1), nameof(Game1.getOnlineFarmers)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetOnlineFarmers))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Game1), nameof(Game1.getAllFarmers)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetAllFarmers))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Game1), nameof(Game1.getFarm)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetFarm))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Game1), nameof(Game1.getSourceRectForStandardTileSheet)),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockGetSourceRectForStandardTileSheet))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Game1), nameof(Game1.playSound), new []{typeof(string), typeof(int?)}),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockPlaySound))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(
> 				typeof(Game1), 
> 				nameof(Game1.drawDialogueBox), 
> 				new []
> 				{
> 					typeof(int),
> 					typeof(int),
> 					typeof(int),
> 					typeof(int),
> 					typeof(bool),
> 					typeof(bool),
> 					typeof(string),
> 					typeof(bool),
> 					typeof(bool),
> 					typeof(int),
> 					typeof(int),
> 					typeof(int)
> 				}
> 			),
> 			prefix: new HarmonyMethod(typeof(HarmonyGame), nameof(MockDrawDialogueBox))
> 		);
> 		DrawDialogueBoxCalls.Clear();
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		GetPlayerResult = null;
> 		GetOnlineFarmersResults = null;
> 		GetAllFarmersResults = null;
> 		GetFarmResult = null;
> 		GetActiveClickableMenuResult = null;
> 		GetOptionsResult = null;
> 		DrawDialogueBoxCalls.Clear();
> 	}
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyModMessageReceivedEventArgs.cs
> ```csharp
> <<<<<<< SEARCH
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(ModMessageReceivedEventArgs)),
> 			prefix: new HarmonyMethod(typeof(HarmonyModMessageReceivedEventArgs), nameof(MockConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			typeof(ModMessageReceivedEventArgs)
> 				.GetMethod(nameof(ModMessageReceivedEventArgs.ReadAs))!
> 				.MakeGenericMethod(typeof(IMessage)),
> 			prefix: new HarmonyMethod(typeof(HarmonyModMessageReceivedEventArgs), nameof(MockReadAs))
> 		);
> 	}
> =======
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(ModMessageReceivedEventArgs)),
> 			prefix: new HarmonyMethod(typeof(HarmonyModMessageReceivedEventArgs), nameof(MockConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			typeof(ModMessageReceivedEventArgs)
> 				.GetMethod(nameof(ModMessageReceivedEventArgs.ReadAs))!
> 				.MakeGenericMethod(typeof(IMessage)),
> 			prefix: new HarmonyMethod(typeof(HarmonyModMessageReceivedEventArgs), nameof(MockReadAs))
> 		);
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		ReadAsMessage = null;
> 	}
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyObject.cs
> ```csharp
> <<<<<<< SEARCH
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(Object), new []{typeof(string), typeof(int), typeof(bool), typeof(int), typeof(int)}),
> 			prefix: new HarmonyMethod(typeof(HarmonyObject), nameof(MockConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Item), nameof(Object.drawInMenu), new []
> 			{
> 				typeof(SpriteBatch),
> 				typeof(Vector2),
> 				typeof(float),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonyObject), nameof(MockDrawInMenu))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Object), nameof(Object.DisplayName)),
> 			prefix: new HarmonyMethod(typeof(HarmonyObject), nameof(MockGetDisplayName))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Object), nameof(Object.sellToStorePrice)),
> 			prefix: new HarmonyMethod(typeof(HarmonyObject), nameof(MockSellToStorePrice))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Object), nameof(Object.getCategoryName)),
> 			prefix: new HarmonyMethod(typeof(HarmonyObject), nameof(MockGetCategoryName))
> 		);
> 
> 		DrawInMenuCalls = new();
> 		ObjectIdCategoryMapping = new();
> 		CategoryIdToNameMapping = new();
> 		ObjectIdToPriceMapping = new();
> 		SellToStorePriceMapping = new();
> 	}
> =======
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(Object), new []{typeof(string), typeof(int), typeof(bool), typeof(int), typeof(int)}),
> 			prefix: new HarmonyMethod(typeof(HarmonyObject), nameof(MockConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Item), nameof(Object.drawInMenu), new []
> 			{
> 				typeof(SpriteBatch),
> 				typeof(Vector2),
> 				typeof(float),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonyObject), nameof(MockDrawInMenu))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.PropertyGetter(typeof(Object), nameof(Object.DisplayName)),
> 			prefix: new HarmonyMethod(typeof(HarmonyObject), nameof(MockGetDisplayName))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Object), nameof(Object.sellToStorePrice)),
> 			prefix: new HarmonyMethod(typeof(HarmonyObject), nameof(MockSellToStorePrice))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.Method(typeof(Object), nameof(Object.getCategoryName)),
> 			prefix: new HarmonyMethod(typeof(HarmonyObject), nameof(MockGetCategoryName))
> 		);
> 
> 		DrawInMenuCalls = new();
> 		ObjectIdCategoryMapping = new();
> 		CategoryIdToNameMapping = new();
> 		ObjectIdToPriceMapping = new();
> 		SellToStorePriceMapping = new();
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		DrawInMenuCalls.Clear();
> 		ObjectIdCategoryMapping.Clear();
> 		CategoryIdToNameMapping.Clear();
> 		ObjectIdToPriceMapping.Clear();
> 		SellToStorePriceMapping.Clear();
> 	}
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonySpriteFont.cs
> ```csharp
> <<<<<<< SEARCH
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(
> 				typeof(SpriteFont),
> 				new []
> 				{
> 					typeof(Texture2D),
> 					typeof(List<Rectangle>),
> 					typeof(List<Rectangle>),
> 					typeof(List<char>),
> 					typeof(int),
> 					typeof(float),
> 					typeof(List<Vector3>),
> 					typeof(char?)
> 				}
> 			),
> 			prefix: new HarmonyMethod(typeof(HarmonySpriteFont), nameof(MockConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.Method(typeof(SpriteFont), nameof(SpriteFont.MeasureString), new []{typeof(string)}),
> 			prefix: new HarmonyMethod(typeof(HarmonySpriteFont), nameof(MockMeasureString))
> 		);
> 	}
> =======
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(
> 				typeof(SpriteFont),
> 				new []
> 				{
> 					typeof(Texture2D),
> 					typeof(List<Rectangle>),
> 					typeof(List<Rectangle>),
> 					typeof(List<char>),
> 					typeof(int),
> 					typeof(float),
> 					typeof(List<Vector3>),
> 					typeof(char?)
> 				}
> 			),
> 			prefix: new HarmonyMethod(typeof(HarmonySpriteFont), nameof(MockConstructor))
> 		);
> 		
> 		harmony.Patch(
> 			AccessTools.Method(typeof(SpriteFont), nameof(SpriteFont.MeasureString), new []{typeof(string)}),
> 			prefix: new HarmonyMethod(typeof(HarmonySpriteFont), nameof(MockMeasureString))
> 		);
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		MeasureStringResult = default;
> 	}
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonySpriteBatch.cs
> ```csharp
> <<<<<<< SEARCH
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(SpriteBatch), new []{typeof(GraphicsDevice), typeof(int)}),
> 			prefix: new HarmonyMethod(typeof(HarmonySpriteBatch), nameof(MockConstructor))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(SpriteBatch), nameof(SpriteBatch.Draw),new []
> 			{
> 				typeof(Texture2D),
> 				typeof(Vector2),
> 				typeof(Rectangle),
> 				typeof(Color),
> 				typeof(float),
> 				typeof(Vector2),
> 				typeof(float),
> 				typeof(SpriteEffects),
> 				typeof(float)
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonySpriteBatch), nameof(MockDraw))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(SpriteBatch), nameof(SpriteBatch.Draw),new []
> 			{
> 				typeof(Texture2D),
> 				typeof(Rectangle),
> 				typeof(Color),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonySpriteBatch), nameof(MockDrawTiny))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(SpriteBatch), nameof(SpriteBatch.Draw),new []
> 			{
> 				typeof(Texture2D),
> 				typeof(Rectangle),
> 				typeof(Rectangle),
> 				typeof(Color),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonySpriteBatch), nameof(MockDrawSmall))
> 		);
> 
> 		DrawCalls = new();
> 	}
> =======
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Constructor(typeof(SpriteBatch), new []{typeof(GraphicsDevice), typeof(int)}),
> 			prefix: new HarmonyMethod(typeof(HarmonySpriteBatch), nameof(MockConstructor))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(SpriteBatch), nameof(SpriteBatch.Draw),new []
> 			{
> 				typeof(Texture2D),
> 				typeof(Vector2),
> 				typeof(Rectangle),
> 				typeof(Color),
> 				typeof(float),
> 				typeof(Vector2),
> 				typeof(float),
> 				typeof(SpriteEffects),
> 				typeof(float)
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonySpriteBatch), nameof(MockDraw))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(SpriteBatch), nameof(SpriteBatch.Draw),new []
> 			{
> 				typeof(Texture2D),
> 				typeof(Rectangle),
> 				typeof(Color),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonySpriteBatch), nameof(MockDrawTiny))
> 		);
> 		harmony.Patch(
> 			AccessTools.Method(typeof(SpriteBatch), nameof(SpriteBatch.Draw),new []
> 			{
> 				typeof(Texture2D),
> 				typeof(Rectangle),
> 				typeof(Rectangle),
> 				typeof(Color),
> 			}),
> 			prefix: new HarmonyMethod(typeof(HarmonySpriteBatch), nameof(MockDrawSmall))
> 		);
> 
> 		DrawCalls = new();
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		DrawCalls.Clear();
> 	}
> >>>>>>> REPLACE
> ```
> 
> Tests/HarmonyMocks/HarmonyUtility.cs
> ```csharp
> <<<<<<< SEARCH
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Method(
> 				typeof(Utility), 
> 				nameof(Utility.drawTextWithShadow),
> 				new []
> 				{
> 					typeof(SpriteBatch),
> 					typeof(string),
> 					typeof(SpriteFont),
> 					typeof(Vector2),
> 					typeof(Color),
> 					typeof(float),
> 					typeof(float),
> 					typeof(int),
> 					typeof(int),
> 					typeof(float),
> 					typeof(int)
> 				}
> 			),
> 			prefix: new HarmonyMethod(typeof(HarmonyUtility), nameof(MockDrawTextWithShadow))
> 		);
> 		DrawTextWithShadowCalls.Clear();
> 	}
> =======
> 	public static void Setup(Harmony harmony)
> 	{
> 		harmony.Patch(
> 			AccessTools.Method(
> 				typeof(Utility), 
> 				nameof(Utility.drawTextWithShadow),
> 				new []
> 				{
> 					typeof(SpriteBatch),
> 					typeof(string),
> 					typeof(SpriteFont),
> 					typeof(Vector2),
> 					typeof(Color),
> 					typeof(float),
> 					typeof(float),
> 					typeof(int),
> 					typeof(int),
> 					typeof(float),
> 					typeof(int)
> 				}
> 			),
> 			prefix: new HarmonyMethod(typeof(HarmonyUtility), nameof(MockDrawTextWithShadow))
> 		);
> 		DrawTextWithShadowCalls.Clear();
> 	}
> 	
> 	public static void TearDown()
> 	{
> 		DrawTextWithShadowCalls.Clear();
> 	}
> >>>>>>> REPLACE
> ```
> 
> > Tokens: 42k sent, 5.0k received. Cost: $0.20 message, $0.79 session.  
> > Applied edit to Tests/HarmonyMocks/HarmonyFarm.cs  
> > Applied edit to Tests/HarmonyMocks/HarmonyGame.cs  
> > Applied edit to Tests/HarmonyMocks/HarmonyModMessageReceivedEventArgs.cs  
> > Applied edit to Tests/HarmonyMocks/HarmonySpriteBatch.cs  
> > Applied edit to Tests/HarmonyMocks/HarmonySpriteFont.cs  
> > Applied edit to Tests/HarmonyMocks/HarmonyFarmer.cs  
> > Applied edit to Tests/HarmonyMocks/HarmonyObject.cs  
> > Applied edit to Tests/HarmonyMocks/HarmonyFarmerCollection.cs  
> > Applied edit to Tests/HarmonyMocks/HarmonyFarmerTeam.cs  
> > Applied edit to Tests/HarmonyMocks/HarmonyUtility.cs  
> > Commit 2fcd311 feat: implement TearDown methods for Harmony mock classes  
> > You can use /undo to undo and discard each aider commit.  
> >  
> >  
> > ^C again to exit  
> >  
> >  
> > ^C KeyboardInterrupt
{{< /details >}}
**Verdict:** ✅ The tool did a good job of a skaffolding this teardown work

## Conclusion

